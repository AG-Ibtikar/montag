"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/sign-in/page",{

/***/ "(app-pages-browser)/./src/lib/firebase.ts":
/*!*****************************!*\
  !*** ./src/lib/firebase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: function() { return /* binding */ FirebaseError; },\n/* harmony export */   analytics: function() { return /* binding */ analytics; },\n/* harmony export */   app: function() { return /* binding */ app; },\n/* harmony export */   auth: function() { return /* binding */ auth; },\n/* harmony export */   createStoryWithStatus: function() { return /* binding */ createStoryWithStatus; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   getStory: function() { return /* binding */ getStory; },\n/* harmony export */   getStoryGenerationStatus: function() { return /* binding */ getStoryGenerationStatus; },\n/* harmony export */   getUserStories: function() { return /* binding */ getUserStories; },\n/* harmony export */   saveStory: function() { return /* binding */ saveStory; },\n/* harmony export */   storiesCollection: function() { return /* binding */ storiesCollection; },\n/* harmony export */   updateStory: function() { return /* binding */ updateStory; },\n/* harmony export */   updateStoryStatus: function() { return /* binding */ updateStoryStatus; }\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_analytics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/analytics */ \"(app-pages-browser)/./node_modules/firebase/analytics/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ storiesCollection,FirebaseError,saveStory,updateStory,getUserStories,getStory,createStoryWithStatus,updateStoryStatus,getStoryGenerationStatus,app,auth,db,analytics auto */ \n\n\n\n// Log environment variables for debugging\nconsole.log(\"Firebase Config:\", {\n    apiKey:  true ? \"Set\" : 0,\n    authDomain:  true ? \"Set\" : 0,\n    projectId:  true ? \"Set\" : 0,\n    storageBucket:  true ? \"Set\" : 0,\n    messagingSenderId:  true ? \"Set\" : 0,\n    appId:  true ? \"Set\" : 0,\n    measurementId:  true ? \"Set\" : 0\n});\nconst firebaseConfig = {\n    apiKey: \"AIzaSyAPjxc_Y70cfxyME-ao3WspK8PCeJaTR7k\",\n    authDomain: \"montajai.firebaseapp.com\",\n    projectId: \"montajai\",\n    storageBucket: \"montajai.firebasestorage.app\",\n    messagingSenderId: \"1074834137884\",\n    appId: \"1:1074834137884:web:acaa300a37b9dadc3e10d9\",\n    measurementId: \"G-HSZ6LZR8Q9\"\n};\n// Initialize Firebase\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)() : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)(app);\nlet analytics;\ntry {\n    // Initialize Analytics only in browser environment\n    if (true) {\n        analytics = (0,firebase_analytics__WEBPACK_IMPORTED_MODULE_3__.getAnalytics)(app);\n    }\n    console.log(\"Firebase initialized successfully\");\n} catch (error) {\n    console.error(\"Error initializing Firebase:\", error);\n    throw error;\n}\n// Add security rules for stories collection\nconst storiesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\");\n// Custom error types for better error handling\nclass FirebaseError extends Error {\n    constructor(message, code, status = 500){\n        super(message);\n        this.code = code;\n        this.status = status;\n        this.name = \"FirebaseError\";\n    }\n}\n// Validation function for story data\nconst validateStory = (story)=>{\n    var _story_title, _story_content, _story_userId;\n    const errors = [];\n    if (!((_story_title = story.title) === null || _story_title === void 0 ? void 0 : _story_title.trim())) {\n        errors.push(\"Title is required\");\n    }\n    if (!((_story_content = story.content) === null || _story_content === void 0 ? void 0 : _story_content.trim())) {\n        errors.push(\"Content is required\");\n    }\n    if (!story.config) {\n        errors.push(\"Configuration is required\");\n    } else {\n        const { industry, companySize, role, experience, focus, tone, format, length } = story.config;\n        if (!(industry === null || industry === void 0 ? void 0 : industry.trim())) errors.push(\"Industry is required\");\n        if (!(companySize === null || companySize === void 0 ? void 0 : companySize.trim())) errors.push(\"Company size is required\");\n        if (!(role === null || role === void 0 ? void 0 : role.trim())) errors.push(\"Role is required\");\n        if (!(experience === null || experience === void 0 ? void 0 : experience.trim())) errors.push(\"Experience is required\");\n        if (!(focus === null || focus === void 0 ? void 0 : focus.trim())) errors.push(\"Focus is required\");\n        if (!(tone === null || tone === void 0 ? void 0 : tone.trim())) errors.push(\"Tone is required\");\n        if (!(format === null || format === void 0 ? void 0 : format.trim())) errors.push(\"Format is required\");\n        if (!(length === null || length === void 0 ? void 0 : length.trim())) errors.push(\"Length is required\");\n    }\n    if (!((_story_userId = story.userId) === null || _story_userId === void 0 ? void 0 : _story_userId.trim())) {\n        errors.push(\"User ID is required\");\n    }\n    if (!story.status || ![\n        \"completed\",\n        \"in_progress\",\n        \"failed\"\n    ].includes(story.status)) {\n        errors.push(\"Invalid status\");\n    }\n    if (errors.length > 0) {\n        throw new FirebaseError(errors.join(\", \"), \"INVALID_DATA\", 400);\n    }\n};\n// Function to save a story to Firestore\nconst saveStory = async (story)=>{\n    try {\n        const storyData = {\n            ...story,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            status: \"completed\"\n        };\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), storyData);\n        return docRef.id;\n    } catch (error) {\n        console.error(\"Error saving story:\", error);\n        throw new Error(\"Failed to save story\");\n    }\n};\n// Function to update a story\nconst updateStory = async (storyId, updates)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Get the existing story to verify ownership\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        // Validate the updated data\n        const updatedStory = {\n            ...storyData,\n            ...updates\n        };\n        validateStory(updatedStory);\n        // Update the story\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, {\n            ...updates,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story:\", error);\n        throw new FirebaseError(\"Failed to update story\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get stories for the current user\nconst getUserStories = async ()=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to fetch stories\", \"UNAUTHENTICATED\", 401);\n        }\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(storiesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", user.uid), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        return querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error fetching stories:\", error);\n        throw new FirebaseError(\"Failed to fetch stories\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get a single story\nconst getStory = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get stories\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId));\n        if (!storyDoc.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storyDoc.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            id: storyDoc.id,\n            ...storyData\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story:\", error);\n        throw new FirebaseError(\"Failed to get story\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to create a story with initial status and error tracking\nconst createStoryWithStatus = async function(story) {\n    let status = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"in_progress\", error = arguments.length > 2 ? arguments[2] : void 0;\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to create stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Create initial story document with error tracking\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)(storiesCollection, {\n            ...story,\n            userId: user.uid,\n            status,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            error: error ? {\n                ...error,\n                timestamp: new Date().toISOString()\n            } : null,\n            generationAttempts: 0,\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return docRef.id;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error creating story:\", error);\n        throw new FirebaseError(\"Failed to create story\", \"CREATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to update story generation status with detailed error tracking\nconst updateStoryStatus = async (storyId, status, error)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        const updates = {\n            status,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        };\n        if (error) {\n            updates.error = {\n                ...error,\n                timestamp: new Date().toISOString()\n            };\n            updates.generationAttempts = (storyData.generationAttempts || 0) + 1;\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, updates);\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story status:\", error);\n        throw new FirebaseError(\"Failed to update story status\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get story generation status\nconst getStoryGenerationStatus = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(docRef);\n        if (!docSnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = docSnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            status: storyData.status,\n            error: storyData.error,\n            generationAttempts: storyData.generationAttempts || 0,\n            lastAttemptAt: storyData.lastAttemptAt\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story status:\", error);\n        throw new FirebaseError(\"Failed to get story status\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFNBQVMxRCx1REFBR0EsQ0FBQzBCLElBQUksV0FBV21DO1FBQ2xDLE1BQU0wQixVQUFVLE1BQU10RiwwREFBTUEsQ0FBQ3lEO1FBRTdCLElBQUksQ0FBQzZCLFFBQVFwQixNQUFNLElBQUk7WUFDckIsTUFBTSxJQUFJckMsY0FBYyxtQkFBbUIsYUFBYTtRQUMxRDtRQUVBLE1BQU0wQixZQUFZK0IsUUFBUW5CLElBQUk7UUFDOUIsSUFBSVosVUFBVUosTUFBTSxLQUFLVyxLQUFLTSxHQUFHLEVBQUU7WUFDakMsTUFBTSxJQUFJdkMsY0FBYyxxQ0FBcUMsZ0JBQWdCO1FBQy9FO1FBRUEsT0FBTztZQUNMSyxRQUFRcUIsVUFBVXJCLE1BQU07WUFDeEJQLE9BQU80QixVQUFVNUIsS0FBSztZQUN0QnVELG9CQUFvQjNCLFVBQVUyQixrQkFBa0IsSUFBSTtZQUNwREMsZUFBZTVCLFVBQVU0QixhQUFhO1FBQ3hDO0lBQ0YsRUFBRSxPQUFPeEQsT0FBTztRQUNkLElBQUlBLGlCQUFpQkUsZUFBZTtZQUNsQyxNQUFNRjtRQUNSO1FBQ0F4QixRQUFRd0IsS0FBSyxDQUFDLCtCQUErQkE7UUFDN0MsTUFBTSxJQUFJRSxjQUNSLDhCQUNBLGVBQ0FGLGlCQUFpQkcsU0FBUyxVQUFVSCxRQUFRLE1BQU07SUFFdEQ7QUFDRixFQUFFO0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZmlyZWJhc2UudHM/MTU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGluaXRpYWxpemVBcHAsIGdldEFwcHMsIGdldEFwcCB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBnZXRBdXRoIH0gZnJvbSAnZmlyZWJhc2UvYXV0aCc7XG5pbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGFkZERvYywgc2VydmVyVGltZXN0YW1wLCBxdWVyeSwgd2hlcmUsIG9yZGVyQnksIGdldERvY3MsIGRvYywgZ2V0RG9jLCB1cGRhdGVEb2MgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgZ2V0QW5hbHl0aWNzIH0gZnJvbSAnZmlyZWJhc2UvYW5hbHl0aWNzJztcbmltcG9ydCB7IFRpbWVzdGFtcCB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5cbi8vIExvZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIGRlYnVnZ2luZ1xuY29uc29sZS5sb2coJ0ZpcmViYXNlIENvbmZpZzonLCB7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBhdXRoRG9tYWluOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTiA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgbWVzc2FnaW5nU2VuZGVySWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgYXBwSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBtZWFzdXJlbWVudElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRCA/ICdTZXQnIDogJ05vdCBTZXQnXG59KTtcblxuY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSxcbiAgYXV0aERvbWFpbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4sXG4gIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCxcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQsXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lELFxuICBhcHBJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lELFxuICBtZWFzdXJlbWVudElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRFxufTtcblxuLy8gSW5pdGlhbGl6ZSBGaXJlYmFzZVxuY29uc3QgYXBwID0gZ2V0QXBwcygpLmxlbmd0aCA/IGdldEFwcCgpIDogaW5pdGlhbGl6ZUFwcChmaXJlYmFzZUNvbmZpZyk7XG5jb25zdCBhdXRoID0gZ2V0QXV0aChhcHApO1xuY29uc3QgZGIgPSBnZXRGaXJlc3RvcmUoYXBwKTtcblxubGV0IGFuYWx5dGljcztcblxudHJ5IHtcbiAgLy8gSW5pdGlhbGl6ZSBBbmFseXRpY3Mgb25seSBpbiBicm93c2VyIGVudmlyb25tZW50XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGFuYWx5dGljcyA9IGdldEFuYWx5dGljcyhhcHApO1xuICB9XG4gIGNvbnNvbGUubG9nKCdGaXJlYmFzZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBGaXJlYmFzZTonLCBlcnJvcik7XG4gIHRocm93IGVycm9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0b3J5Q29uZmlnIHtcbiAgaW5kdXN0cnk6IHN0cmluZztcbiAgY29tcGFueVNpemU6IHN0cmluZztcbiAgcm9sZTogc3RyaW5nO1xuICBleHBlcmllbmNlOiBzdHJpbmc7XG4gIGZvY3VzOiBzdHJpbmc7XG4gIHRvbmU6IHN0cmluZztcbiAgZm9ybWF0OiBzdHJpbmc7XG4gIGxlbmd0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0b3J5IHtcbiAgaWQ/OiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgY29uZmlnOiBTdG9yeUNvbmZpZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIHN0YXR1czogJ2NvbXBsZXRlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2ZhaWxlZCc7XG4gIGNyZWF0ZWRBdDogVGltZXN0YW1wO1xuICBlcnJvcj86IFN0b3J5R2VuZXJhdGlvbkVycm9yO1xuICBnZW5lcmF0aW9uQXR0ZW1wdHM/OiBudW1iZXI7XG4gIGxhc3RBdHRlbXB0QXQ/OiBhbnk7XG4gIHN0b3J5U3R5bGU6IHN0cmluZztcbiAgYWNTdHlsZTogc3RyaW5nO1xufVxuXG4vLyBBZGQgc2VjdXJpdHkgcnVsZXMgZm9yIHN0b3JpZXMgY29sbGVjdGlvblxuZXhwb3J0IGNvbnN0IHN0b3JpZXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKTtcblxuLy8gQ3VzdG9tIGVycm9yIHR5cGVzIGZvciBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbmV4cG9ydCBjbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIGNvZGU6IHN0cmluZyxcbiAgICBwdWJsaWMgc3RhdHVzOiBudW1iZXIgPSA1MDBcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0ZpcmViYXNlRXJyb3InO1xuICB9XG59XG5cbi8vIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIHN0b3J5IGRhdGFcbmNvbnN0IHZhbGlkYXRlU3RvcnkgPSAoc3Rvcnk6IE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0Jz4pID0+IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmICghc3RvcnkudGl0bGU/LnRyaW0oKSkge1xuICAgIGVycm9ycy5wdXNoKCdUaXRsZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKCFzdG9yeS5jb250ZW50Py50cmltKCkpIHtcbiAgICBlcnJvcnMucHVzaCgnQ29udGVudCBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKCFzdG9yeS5jb25maWcpIHtcbiAgICBlcnJvcnMucHVzaCgnQ29uZmlndXJhdGlvbiBpcyByZXF1aXJlZCcpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgaW5kdXN0cnksIGNvbXBhbnlTaXplLCByb2xlLCBleHBlcmllbmNlLCBmb2N1cywgdG9uZSwgZm9ybWF0LCBsZW5ndGggfSA9IHN0b3J5LmNvbmZpZztcbiAgICBpZiAoIWluZHVzdHJ5Py50cmltKCkpIGVycm9ycy5wdXNoKCdJbmR1c3RyeSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghY29tcGFueVNpemU/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0NvbXBhbnkgc2l6ZSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghcm9sZT8udHJpbSgpKSBlcnJvcnMucHVzaCgnUm9sZSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghZXhwZXJpZW5jZT8udHJpbSgpKSBlcnJvcnMucHVzaCgnRXhwZXJpZW5jZSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghZm9jdXM/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0ZvY3VzIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCF0b25lPy50cmltKCkpIGVycm9ycy5wdXNoKCdUb25lIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCFmb3JtYXQ/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0Zvcm1hdCBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghbGVuZ3RoPy50cmltKCkpIGVycm9ycy5wdXNoKCdMZW5ndGggaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmICghc3RvcnkudXNlcklkPy50cmltKCkpIHtcbiAgICBlcnJvcnMucHVzaCgnVXNlciBJRCBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgaWYgKCFzdG9yeS5zdGF0dXMgfHwgIVsnY29tcGxldGVkJywgJ2luX3Byb2dyZXNzJywgJ2ZhaWxlZCddLmluY2x1ZGVzKHN0b3J5LnN0YXR1cykpIHtcbiAgICBlcnJvcnMucHVzaCgnSW52YWxpZCBzdGF0dXMnKTtcbiAgfVxuXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKGVycm9ycy5qb2luKCcsICcpLCAnSU5WQUxJRF9EQVRBJywgNDAwKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gc2F2ZSBhIHN0b3J5IHRvIEZpcmVzdG9yZVxuZXhwb3J0IGNvbnN0IHNhdmVTdG9yeSA9IGFzeW5jIChzdG9yeTogT21pdDxTdG9yeSwgJ2lkJyB8ICdjcmVhdGVkQXQnPik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RvcnlEYXRhID0ge1xuICAgICAgLi4uc3RvcnksXG4gICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyBhcyBjb25zdFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdzdG9yaWVzJyksIHN0b3J5RGF0YSk7XG4gICAgcmV0dXJuIGRvY1JlZi5pZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgc3Rvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgc3RvcnknKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gdXBkYXRlIGEgc3RvcnlcbmV4cG9ydCBjb25zdCB1cGRhdGVTdG9yeSA9IGFzeW5jIChzdG9yeUlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8T21pdDxTdG9yeSwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VzZXJJZCc+PikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIHVwZGF0ZSBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBleGlzdGluZyBzdG9yeSB0byB2ZXJpZnkgb3duZXJzaGlwXG4gICAgY29uc3Qgc3RvcnlSZWYgPSBkb2MoZGIsICdzdG9yaWVzJywgc3RvcnlJZCk7XG4gICAgY29uc3Qgc3RvcnlTbmFwID0gYXdhaXQgZ2V0RG9jKHN0b3J5UmVmKTtcblxuICAgIGlmICghc3RvcnlTbmFwLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignU3Rvcnkgbm90IGZvdW5kJywgJ05PVF9GT1VORCcsIDQwNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEYXRhID0gc3RvcnlTbmFwLmRhdGEoKSBhcyBTdG9yeTtcbiAgICBpZiAoc3RvcnlEYXRhLnVzZXJJZCAhPT0gdXNlci51aWQpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVbmF1dGhvcml6ZWQgdG8gdXBkYXRlIHRoaXMgc3RvcnknLCAnVU5BVVRIT1JJWkVEJywgNDAzKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgdXBkYXRlZCBkYXRhXG4gICAgY29uc3QgdXBkYXRlZFN0b3J5ID0geyAuLi5zdG9yeURhdGEsIC4uLnVwZGF0ZXMgfTtcbiAgICB2YWxpZGF0ZVN0b3J5KHVwZGF0ZWRTdG9yeSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHN0b3J5XG4gICAgYXdhaXQgdXBkYXRlRG9jKHN0b3J5UmVmLCB7XG4gICAgICAuLi51cGRhdGVzLFxuICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiBzdG9yeUlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzdG9yeTonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoXG4gICAgICAnRmFpbGVkIHRvIHVwZGF0ZSBzdG9yeScsXG4gICAgICAnVVBEQVRFX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gZ2V0IHN0b3JpZXMgZm9yIHRoZSBjdXJyZW50IHVzZXJcbmV4cG9ydCBjb25zdCBnZXRVc2VyU3RvcmllcyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byBmZXRjaCBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgc3Rvcmllc0NvbGxlY3Rpb24sXG4gICAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlci51aWQpLFxuICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKVxuICAgICk7XG5cbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAuLi5kb2MuZGF0YSgpXG4gICAgfSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzdG9yaWVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gZmV0Y2ggc3RvcmllcycsXG4gICAgICAnRkVUQ0hfRVJST1InLFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IgPyA1MDAgOiA1MDBcbiAgICApO1xuICB9XG59O1xuXG4vLyBGdW5jdGlvbiB0byBnZXQgYSBzaW5nbGUgc3RvcnlcbmV4cG9ydCBjb25zdCBnZXRTdG9yeSA9IGFzeW5jIChzdG9yeUlkOiBzdHJpbmcpOiBQcm9taXNlPFN0b3J5IHwgbnVsbD4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGdldCBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAnc3RvcmllcycsIHN0b3J5SWQpKTtcbiAgICBpZiAoIXN0b3J5RG9jLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignU3Rvcnkgbm90IGZvdW5kJywgJ05PVF9GT1VORCcsIDQwNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEYXRhID0gc3RvcnlEb2MuZGF0YSgpIGFzIFN0b3J5O1xuICAgIGlmIChzdG9yeURhdGEudXNlcklkICE9PSB1c2VyLnVpZCkge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VuYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBzdG9yeScsICdVTkFVVEhPUklaRUQnLCA0MDMpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpZDogc3RvcnlEb2MuaWQsXG4gICAgICAuLi5zdG9yeURhdGFcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0b3J5OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gZ2V0IHN0b3J5JyxcbiAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEFkZCBuZXcgZXJyb3IgdHlwZXMgZm9yIHN0b3J5IGdlbmVyYXRpb25cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcnlHZW5lcmF0aW9uRXJyb3Ige1xuICBjb2RlOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgZGV0YWlscz86IGFueTtcbiAgdGltZXN0YW1wOiBEYXRlO1xuICByZXRyeUNvdW50PzogbnVtYmVyO1xufVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgYSBzdG9yeSB3aXRoIGluaXRpYWwgc3RhdHVzIGFuZCBlcnJvciB0cmFja2luZ1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0b3J5V2l0aFN0YXR1cyA9IGFzeW5jIChcbiAgc3Rvcnk6IE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0JyB8ICdzdGF0dXMnPixcbiAgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIHwgJ2ZhaWxlZCcgPSAnaW5fcHJvZ3Jlc3MnLFxuICBlcnJvcj86IFN0b3J5R2VuZXJhdGlvbkVycm9yXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byBjcmVhdGUgc3RvcmllcycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBpbml0aWFsIHN0b3J5IGRvY3VtZW50IHdpdGggZXJyb3IgdHJhY2tpbmdcbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2Moc3Rvcmllc0NvbGxlY3Rpb24sIHtcbiAgICAgIC4uLnN0b3J5LFxuICAgICAgdXNlcklkOiB1c2VyLnVpZCxcbiAgICAgIHN0YXR1cyxcbiAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICBlcnJvcjogZXJyb3IgPyB7XG4gICAgICAgIC4uLmVycm9yLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSA6IG51bGwsXG4gICAgICBnZW5lcmF0aW9uQXR0ZW1wdHM6IDAsXG4gICAgICBsYXN0QXR0ZW1wdEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRvY1JlZi5pZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgc3Rvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgc3RvcnknLFxuICAgICAgJ0NSRUFURV9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdG9yeSBnZW5lcmF0aW9uIHN0YXR1cyB3aXRoIGRldGFpbGVkIGVycm9yIHRyYWNraW5nXG5leHBvcnQgY29uc3QgdXBkYXRlU3RvcnlTdGF0dXMgPSBhc3luYyAoXG4gIHN0b3J5SWQ6IHN0cmluZyxcbiAgc3RhdHVzOiAnY29tcGxldGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnZmFpbGVkJyxcbiAgZXJyb3I/OiBTdG9yeUdlbmVyYXRpb25FcnJvclxuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gdXBkYXRlIHN0b3J5IHN0YXR1cycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3J5UmVmID0gZG9jKGRiLCAnc3RvcmllcycsIHN0b3J5SWQpO1xuICAgIGNvbnN0IHN0b3J5U25hcCA9IGF3YWl0IGdldERvYyhzdG9yeVJlZik7XG5cbiAgICBpZiAoIXN0b3J5U25hcC5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1N0b3J5IG5vdCBmb3VuZCcsICdOT1RfRk9VTkQnLCA0MDQpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3J5RGF0YSA9IHN0b3J5U25hcC5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIHVwZGF0ZSB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlczogYW55ID0ge1xuICAgICAgc3RhdHVzLFxuICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGxhc3RBdHRlbXB0QXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgfTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdXBkYXRlcy5lcnJvciA9IHtcbiAgICAgICAgLi4uZXJyb3IsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgICAgdXBkYXRlcy5nZW5lcmF0aW9uQXR0ZW1wdHMgPSAoc3RvcnlEYXRhLmdlbmVyYXRpb25BdHRlbXB0cyB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgYXdhaXQgdXBkYXRlRG9jKHN0b3J5UmVmLCB1cGRhdGVzKTtcbiAgICByZXR1cm4gc3RvcnlJZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgc3Rvcnkgc3RhdHVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gdXBkYXRlIHN0b3J5IHN0YXR1cycsXG4gICAgICAnVVBEQVRFX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gZ2V0IHN0b3J5IGdlbmVyYXRpb24gc3RhdHVzXG5leHBvcnQgY29uc3QgZ2V0U3RvcnlHZW5lcmF0aW9uU3RhdHVzID0gYXN5bmMgKHN0b3J5SWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGdldCBzdG9yeSBzdGF0dXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsICdzdG9yaWVzJywgc3RvcnlJZCk7XG4gICAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xuXG4gICAgaWYgKCFkb2NTbmFwLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignU3Rvcnkgbm90IGZvdW5kJywgJ05PVF9GT1VORCcsIDQwNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEYXRhID0gZG9jU25hcC5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogc3RvcnlEYXRhLnN0YXR1cyxcbiAgICAgIGVycm9yOiBzdG9yeURhdGEuZXJyb3IsXG4gICAgICBnZW5lcmF0aW9uQXR0ZW1wdHM6IHN0b3J5RGF0YS5nZW5lcmF0aW9uQXR0ZW1wdHMgfHwgMCxcbiAgICAgIGxhc3RBdHRlbXB0QXQ6IHN0b3J5RGF0YS5sYXN0QXR0ZW1wdEF0XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzdG9yeSBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byBnZXQgc3Rvcnkgc3RhdHVzJyxcbiAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IGFwcCwgYXV0aCwgZGIsIGFuYWx5dGljcyB9OyAiXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEFwcHMiLCJnZXRBcHAiLCJnZXRBdXRoIiwiZ2V0RmlyZXN0b3JlIiwiY29sbGVjdGlvbiIsImFkZERvYyIsInNlcnZlclRpbWVzdGFtcCIsInF1ZXJ5Iiwid2hlcmUiLCJvcmRlckJ5IiwiZ2V0RG9jcyIsImRvYyIsImdldERvYyIsInVwZGF0ZURvYyIsImdldEFuYWx5dGljcyIsImNvbnNvbGUiLCJsb2ciLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSIsImF1dGhEb21haW4iLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTiIsInByb2plY3RJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQiLCJzdG9yYWdlQnVja2V0IiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQiLCJtZXNzYWdpbmdTZW5kZXJJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQiLCJhcHBJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCIsIm1lYXN1cmVtZW50SWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRCIsImZpcmViYXNlQ29uZmlnIiwiYXBwIiwibGVuZ3RoIiwiYXV0aCIsImRiIiwiYW5hbHl0aWNzIiwiZXJyb3IiLCJzdG9yaWVzQ29sbGVjdGlvbiIsIkZpcmViYXNlRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNvZGUiLCJzdGF0dXMiLCJuYW1lIiwidmFsaWRhdGVTdG9yeSIsInN0b3J5IiwiZXJyb3JzIiwidGl0bGUiLCJ0cmltIiwicHVzaCIsImNvbnRlbnQiLCJjb25maWciLCJpbmR1c3RyeSIsImNvbXBhbnlTaXplIiwicm9sZSIsImV4cGVyaWVuY2UiLCJmb2N1cyIsInRvbmUiLCJmb3JtYXQiLCJ1c2VySWQiLCJpbmNsdWRlcyIsImpvaW4iLCJzYXZlU3RvcnkiLCJzdG9yeURhdGEiLCJjcmVhdGVkQXQiLCJkb2NSZWYiLCJpZCIsInVwZGF0ZVN0b3J5Iiwic3RvcnlJZCIsInVwZGF0ZXMiLCJ1c2VyIiwiY3VycmVudFVzZXIiLCJzdG9yeVJlZiIsInN0b3J5U25hcCIsImV4aXN0cyIsImRhdGEiLCJ1aWQiLCJ1cGRhdGVkU3RvcnkiLCJ1cGRhdGVkQXQiLCJnZXRVc2VyU3RvcmllcyIsInEiLCJxdWVyeVNuYXBzaG90IiwiZG9jcyIsIm1hcCIsImdldFN0b3J5Iiwic3RvcnlEb2MiLCJjcmVhdGVTdG9yeVdpdGhTdGF0dXMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJnZW5lcmF0aW9uQXR0ZW1wdHMiLCJsYXN0QXR0ZW1wdEF0IiwidXBkYXRlU3RvcnlTdGF0dXMiLCJnZXRTdG9yeUdlbmVyYXRpb25TdGF0dXMiLCJkb2NTbmFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firebase.ts\n"));

/***/ })

});