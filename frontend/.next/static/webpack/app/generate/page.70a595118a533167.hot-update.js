"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/generate/page",{

/***/ "(app-pages-browser)/./src/lib/firebase.ts":
/*!*****************************!*\
  !*** ./src/lib/firebase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: function() { return /* binding */ FirebaseError; },\n/* harmony export */   analytics: function() { return /* binding */ analytics; },\n/* harmony export */   app: function() { return /* binding */ app; },\n/* harmony export */   auth: function() { return /* binding */ auth; },\n/* harmony export */   batchDeleteStories: function() { return /* binding */ batchDeleteStories; },\n/* harmony export */   batchSaveStories: function() { return /* binding */ batchSaveStories; },\n/* harmony export */   createStoryWithStatus: function() { return /* binding */ createStoryWithStatus; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   getStories: function() { return /* binding */ getStories; },\n/* harmony export */   getStoriesPaginated: function() { return /* binding */ getStoriesPaginated; },\n/* harmony export */   getStory: function() { return /* binding */ getStory; },\n/* harmony export */   getStoryGenerationStatus: function() { return /* binding */ getStoryGenerationStatus; },\n/* harmony export */   getStoryStats: function() { return /* binding */ getStoryStats; },\n/* harmony export */   saveStory: function() { return /* binding */ saveStory; },\n/* harmony export */   searchStories: function() { return /* binding */ searchStories; },\n/* harmony export */   storiesCollection: function() { return /* binding */ storiesCollection; },\n/* harmony export */   updateStory: function() { return /* binding */ updateStory; },\n/* harmony export */   updateStoryStatus: function() { return /* binding */ updateStoryStatus; }\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_analytics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/analytics */ \"(app-pages-browser)/./node_modules/firebase/analytics/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ storiesCollection,FirebaseError,getStories,saveStory,updateStory,getStory,createStoryWithStatus,updateStoryStatus,getStoryGenerationStatus,batchSaveStories,batchDeleteStories,getStoriesPaginated,searchStories,getStoryStats,app,auth,db,analytics auto */ \n\n\n\n// Log environment variables for debugging\nconsole.log(\"Firebase Config:\", {\n    apiKey:  true ? \"Set\" : 0,\n    authDomain:  true ? \"Set\" : 0,\n    projectId:  true ? \"Set\" : 0,\n    storageBucket:  true ? \"Set\" : 0,\n    messagingSenderId:  true ? \"Set\" : 0,\n    appId:  true ? \"Set\" : 0,\n    measurementId:  true ? \"Set\" : 0\n});\nconst firebaseConfig = {\n    apiKey: \"AIzaSyAPjxc_Y70cfxyME-ao3WspK8PCeJaTR7k\",\n    authDomain: \"montajai.firebaseapp.com\",\n    projectId: \"montajai\",\n    storageBucket: \"montajai.firebasestorage.app\",\n    messagingSenderId: \"1074834137884\",\n    appId: \"1:1074834137884:web:acaa300a37b9dadc3e10d9\",\n    measurementId: \"G-HSZ6LZR8Q9\"\n};\n// Add connection status tracking\nlet isConnected = false;\n// Initialize Firebase with connection monitoring\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)() : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)(app);\n// Enable offline persistence\nif (true) {\n    (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.enableIndexedDbPersistence)(db).catch((err)=>{\n        if (err.code === \"failed-precondition\") {\n            console.warn(\"Multiple tabs open, persistence can only be enabled in one tab at a time.\");\n        } else if (err.code === \"unimplemented\") {\n            console.warn(\"The current browser does not support persistence.\");\n        }\n    });\n}\n// Monitor connection status using onSnapshot\nconst connectionRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"_health\", \"connection\");\n(0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.onSnapshot)(connectionRef, ()=>{\n    isConnected = true;\n    console.log(\"Firebase connected successfully\");\n}, (error)=>{\n    console.error(\"Firebase connection error:\", error);\n    isConnected = false;\n});\n// Connection status check function\nconst checkConnection = async ()=>{\n    if (!isConnected) {\n        try {\n            // Try a simple read operation to check connection\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(connectionRef);\n            isConnected = true;\n            return true;\n        } catch (error) {\n            console.error(\"Failed to establish connection:\", error);\n            return false;\n        }\n    }\n    return true;\n};\n// Retry utility function\nconst withRetry = async function(operation) {\n    let maxRetries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, delay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1000;\n    let lastError = null;\n    for(let attempt = 1; attempt <= maxRetries; attempt++){\n        try {\n            // Check connection before each attempt\n            if (!await checkConnection()) {\n                throw new Error(\"No connection to Firebase\");\n            }\n            return await operation();\n        } catch (error) {\n            lastError = error;\n            console.warn(\"Attempt \".concat(attempt, \" failed:\"), error);\n            if (attempt < maxRetries) {\n                // Exponential backoff\n                const backoffDelay = delay * Math.pow(2, attempt - 1);\n                await new Promise((resolve)=>setTimeout(resolve, backoffDelay));\n            }\n        }\n    }\n    throw lastError;\n};\n// Enhanced error logging\nconst logError = (operation, error, context)=>{\n    const errorDetails = {\n        timestamp: new Date().toISOString(),\n        operation,\n        error: error instanceof Error ? {\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n            code: \"code\" in error ? error.code : undefined\n        } : error,\n        context,\n        connectionStatus: isConnected\n    };\n    console.error(\"Firebase Operation Error:\", errorDetails);\n    return errorDetails;\n};\nlet analytics;\ntry {\n    // Initialize Analytics only in browser environment\n    if (true) {\n        analytics = (0,firebase_analytics__WEBPACK_IMPORTED_MODULE_3__.getAnalytics)(app);\n    }\n    console.log(\"Firebase initialized successfully\");\n} catch (error) {\n    console.error(\"Error initializing Firebase:\", error);\n    throw error;\n}\n// Initialize collections\nconst storiesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\");\n// Custom error types for better error handling\nclass FirebaseError extends Error {\n    constructor(message, code, status = 500){\n        super(message);\n        this.code = code;\n        this.status = status;\n        this.name = \"FirebaseError\";\n    }\n}\n// Enhanced validation function\nconst validateStory = (story)=>{\n    var _story_title, _story_content, _story_userId;\n    const errors = [];\n    // Required fields validation\n    if (!((_story_title = story.title) === null || _story_title === void 0 ? void 0 : _story_title.trim())) errors.push(\"Title is required\");\n    if (!((_story_content = story.content) === null || _story_content === void 0 ? void 0 : _story_content.trim())) errors.push(\"Content is required\");\n    if (!((_story_userId = story.userId) === null || _story_userId === void 0 ? void 0 : _story_userId.trim())) errors.push(\"User ID is required\");\n    // Config validation\n    if (!story.config) {\n        errors.push(\"Configuration is required\");\n    } else {\n        const { focus, tone, format, length } = story.config;\n        if (!(focus === null || focus === void 0 ? void 0 : focus.trim())) errors.push(\"Focus is required\");\n        if (!(tone === null || tone === void 0 ? void 0 : tone.trim())) errors.push(\"Tone is required\");\n        if (!(format === null || format === void 0 ? void 0 : format.trim())) errors.push(\"Format is required\");\n        if (!(length === null || length === void 0 ? void 0 : length.trim())) errors.push(\"Length is required\");\n    }\n    // Status validation\n    if (!story.status || ![\n        \"completed\",\n        \"in_progress\",\n        \"failed\"\n    ].includes(story.status)) {\n        errors.push(\"Invalid status\");\n    }\n    // Content length validation\n    if (story.content.length < 50) {\n        errors.push(\"Content must be at least 50 characters long\");\n    }\n    if (errors.length > 0) {\n        throw new FirebaseError(errors.join(\", \"), \"INVALID_DATA\", 400);\n    }\n};\n// Function to get stories for the current user\nconst getStories = async ()=>{\n    return withRetry(async ()=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) {\n                throw new FirebaseError(\"User must be authenticated to fetch stories\", \"UNAUTHENTICATED\", 401);\n            }\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(storiesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", user.uid), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n            return querySnapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...doc.data()\n                }));\n        } catch (error) {\n            var _auth_currentUser;\n            logError(\"getStories\", error, {\n                userId: (_auth_currentUser = auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.uid\n            });\n            if (error instanceof FirebaseError) {\n                throw error;\n            }\n            throw new FirebaseError(\"Failed to fetch stories. Please try again later.\", \"FETCH_ERROR\", 500);\n        }\n    });\n};\n// Function to save a story to Firestore\nconst saveStory = async (story)=>{\n    return withRetry(async ()=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) {\n                throw new FirebaseError(\"User must be authenticated to save stories\", \"UNAUTHENTICATED\", 401);\n            }\n            validateStory(story);\n            const storyData = {\n                ...story,\n                userId: user.uid,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n                status: \"completed\",\n                generationAttempts: 0,\n                lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n            };\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)(storiesCollection, storyData);\n            return docRef.id;\n        } catch (error) {\n            var _auth_currentUser;\n            logError(\"saveStory\", error, {\n                userId: (_auth_currentUser = auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.uid,\n                storyTitle: story.title,\n                storyConfig: story.config\n            });\n            if (error instanceof Error) {\n                if (\"code\" in error) {\n                    const firebaseError = error;\n                    switch(firebaseError.code){\n                        case \"permission-denied\":\n                            throw new FirebaseError(\"Permission denied. Please check your authentication status.\", \"PERMISSION_DENIED\", 403);\n                        case \"unauthenticated\":\n                            throw new FirebaseError(\"Please sign in to save stories.\", \"UNAUTHENTICATED\", 401);\n                        case \"invalid-argument\":\n                            throw new FirebaseError(\"Invalid story data provided.\", \"INVALID_DATA\", 400);\n                        default:\n                            throw new FirebaseError(\"Failed to save story. Please try again.\", \"SAVE_ERROR\", 500);\n                    }\n                }\n            }\n            throw new FirebaseError(\"Failed to save story. Please try again.\", \"SAVE_ERROR\", 500);\n        }\n    });\n};\n// Function to update a story\nconst updateStory = async (storyId, updates)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Get the existing story to verify ownership\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        // Validate the updated data\n        const updatedStory = {\n            ...storyData,\n            ...updates\n        };\n        validateStory(updatedStory);\n        // Update the story\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, {\n            ...updates,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story:\", error);\n        throw new FirebaseError(\"Failed to update story\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get a single story\nconst getStory = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get stories\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId));\n        if (!storyDoc.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storyDoc.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            id: storyDoc.id,\n            ...storyData\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story:\", error);\n        throw new FirebaseError(\"Failed to get story\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to create a story with initial status and error tracking\nconst createStoryWithStatus = async function(story) {\n    let status = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"in_progress\", error = arguments.length > 2 ? arguments[2] : void 0;\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to create stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Create initial story document with error tracking\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)(storiesCollection, {\n            ...story,\n            userId: user.uid,\n            status,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            error: error ? {\n                ...error,\n                timestamp: new Date().toISOString()\n            } : null,\n            generationAttempts: 0,\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return docRef.id;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error creating story:\", error);\n        throw new FirebaseError(\"Failed to create story\", \"CREATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to update story generation status with detailed error tracking\nconst updateStoryStatus = async (storyId, status, error)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        const updates = {\n            status,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        };\n        if (error) {\n            updates.error = {\n                ...error,\n                timestamp: new Date().toISOString()\n            };\n            updates.generationAttempts = (storyData.generationAttempts || 0) + 1;\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, updates);\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story status:\", error);\n        throw new FirebaseError(\"Failed to update story status\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get story generation status\nconst getStoryGenerationStatus = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(docRef);\n        if (!docSnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = docSnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            status: storyData.status,\n            error: storyData.error,\n            generationAttempts: storyData.generationAttempts || 0,\n            lastAttemptAt: storyData.lastAttemptAt\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story status:\", error);\n        throw new FirebaseError(\"Failed to get story status\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Batch operations\nconst batchSaveStories = async (stories)=>{\n    try {\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.writeBatch)(db);\n        const storyIds = [];\n        stories.forEach((story)=>{\n            validateStory(story);\n            const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"));\n            batch.set(storyRef, {\n                ...story,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n                status: \"completed\"\n            });\n            storyIds.push(storyRef.id);\n        });\n        await batch.commit();\n        return storyIds;\n    } catch (error) {\n        console.error(\"Error batch saving stories:\", error);\n        throw new Error(\"Failed to batch save stories\");\n    }\n};\nconst batchDeleteStories = async (storyIds)=>{\n    try {\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.writeBatch)(db);\n        storyIds.forEach((id)=>{\n            const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", id);\n            batch.delete(storyRef);\n        });\n        await batch.commit();\n    } catch (error) {\n        console.error(\"Error batch deleting stories:\", error);\n        throw new Error(\"Failed to batch delete stories\");\n    }\n};\n// Pagination support\nconst getStoriesPaginated = async function(userId) {\n    let pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, lastDoc = arguments.length > 2 ? arguments[2] : void 0;\n    try {\n        let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.limit)(pageSize));\n        if (lastDoc) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.startAfter)(lastDoc));\n        }\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const stories = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        return {\n            stories,\n            lastDoc: querySnapshot.docs[querySnapshot.docs.length - 1] || null\n        };\n    } catch (error) {\n        console.error(\"Error getting paginated stories:\", error);\n        throw new Error(\"Failed to get paginated stories\");\n    }\n};\n// Search stories\nconst searchStories = async (userId, searchTerm)=>{\n    try {\n        const storiesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(storiesQuery);\n        const stories = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Client-side search for better flexibility\n        return stories.filter((story)=>story.title.toLowerCase().includes(searchTerm.toLowerCase()) || story.content.toLowerCase().includes(searchTerm.toLowerCase()) || story.config.focus.toLowerCase().includes(searchTerm.toLowerCase()) || story.config.tone.toLowerCase().includes(searchTerm.toLowerCase()));\n    } catch (error) {\n        console.error(\"Error searching stories:\", error);\n        throw new Error(\"Failed to search stories\");\n    }\n};\n// Story statistics\nconst getStoryStats = async (userId)=>{\n    try {\n        const storiesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(storiesQuery);\n        const stories = querySnapshot.docs.map((doc)=>doc.data());\n        const stats = {\n            total: stories.length,\n            completed: 0,\n            inProgress: 0,\n            failed: 0,\n            byFocus: {},\n            byTone: {}\n        };\n        stories.forEach((story)=>{\n            // Count by status\n            stats[story.status]++;\n            // Count by focus\n            stats.byFocus[story.config.focus] = (stats.byFocus[story.config.focus] || 0) + 1;\n            // Count by tone\n            stats.byTone[story.config.tone] = (stats.byTone[story.config.tone] || 0) + 1;\n        });\n        return stats;\n    } catch (error) {\n        console.error(\"Error getting story stats:\", error);\n        throw new Error(\"Failed to get story statistics\");\n    }\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFDZDdCLFFBQVE2QixLQUFLLENBQUMsOEJBQThCQTtRQUM1QyxNQUFNLElBQUlRLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZmlyZWJhc2UudHM/MTU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGluaXRpYWxpemVBcHAsIGdldEFwcHMsIGdldEFwcCB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBnZXRBdXRoIH0gZnJvbSAnZmlyZWJhc2UvYXV0aCc7XG5pbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGFkZERvYywgc2VydmVyVGltZXN0YW1wLCBxdWVyeSwgd2hlcmUsIG9yZGVyQnksIGdldERvY3MsIGRvYywgZ2V0RG9jLCB1cGRhdGVEb2MsIHdyaXRlQmF0Y2gsIGRlbGV0ZURvYywgbGltaXQsIHN0YXJ0QWZ0ZXIsIERvY3VtZW50U25hcHNob3QsIG9uU25hcHNob3QsIGVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlIH0gZnJvbSAnZmlyZWJhc2UvZmlyZXN0b3JlJztcbmltcG9ydCB7IGdldEFuYWx5dGljcyB9IGZyb20gJ2ZpcmViYXNlL2FuYWx5dGljcyc7XG5pbXBvcnQgeyBUaW1lc3RhbXAgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuXG4vLyBMb2cgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZvciBkZWJ1Z2dpbmdcbmNvbnNvbGUubG9nKCdGaXJlYmFzZSBDb25maWc6Jywge1xuICBhcGlLZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVkgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgYXV0aERvbWFpbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4gPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgcHJvamVjdElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEID8gJ1NldCcgOiAnTm90IFNldCcsXG4gIHN0b3JhZ2VCdWNrZXQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1NUT1JBR0VfQlVDS0VUID8gJ1NldCcgOiAnTm90IFNldCcsXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEID8gJ1NldCcgOiAnTm90IFNldCcsXG4gIGFwcElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgbWVhc3VyZW1lbnRJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVBU1VSRU1FTlRfSUQgPyAnU2V0JyA6ICdOb3QgU2V0J1xufSk7XG5cbmNvbnN0IGZpcmViYXNlQ29uZmlnID0ge1xuICBhcGlLZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVksXG4gIGF1dGhEb21haW46IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOLFxuICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQsXG4gIHN0b3JhZ2VCdWNrZXQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1NUT1JBR0VfQlVDS0VULFxuICBtZXNzYWdpbmdTZW5kZXJJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVTU0FHSU5HX1NFTkRFUl9JRCxcbiAgYXBwSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCxcbiAgbWVhc3VyZW1lbnRJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVBU1VSRU1FTlRfSURcbn07XG5cbi8vIEFkZCBjb25uZWN0aW9uIHN0YXR1cyB0cmFja2luZ1xubGV0IGlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbi8vIEluaXRpYWxpemUgRmlyZWJhc2Ugd2l0aCBjb25uZWN0aW9uIG1vbml0b3JpbmdcbmNvbnN0IGFwcCA9IGdldEFwcHMoKS5sZW5ndGggPyBnZXRBcHAoKSA6IGluaXRpYWxpemVBcHAoZmlyZWJhc2VDb25maWcpO1xuY29uc3QgYXV0aCA9IGdldEF1dGgoYXBwKTtcbmNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGFwcCk7XG5cbi8vIEVuYWJsZSBvZmZsaW5lIHBlcnNpc3RlbmNlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZW5hYmxlSW5kZXhlZERiUGVyc2lzdGVuY2UoZGIpLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAoZXJyLmNvZGUgPT09ICdmYWlsZWQtcHJlY29uZGl0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdNdWx0aXBsZSB0YWJzIG9wZW4sIHBlcnNpc3RlbmNlIGNhbiBvbmx5IGJlIGVuYWJsZWQgaW4gb25lIHRhYiBhdCBhIHRpbWUuJyk7XG4gICAgfSBlbHNlIGlmIChlcnIuY29kZSA9PT0gJ3VuaW1wbGVtZW50ZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBjdXJyZW50IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBwZXJzaXN0ZW5jZS4nKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBNb25pdG9yIGNvbm5lY3Rpb24gc3RhdHVzIHVzaW5nIG9uU25hcHNob3RcbmNvbnN0IGNvbm5lY3Rpb25SZWYgPSBkb2MoZGIsICdfaGVhbHRoJywgJ2Nvbm5lY3Rpb24nKTtcbm9uU25hcHNob3QoY29ubmVjdGlvblJlZiwgXG4gICgpID0+IHtcbiAgICBpc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgY29uc29sZS5sb2coJ0ZpcmViYXNlIGNvbm5lY3RlZCBzdWNjZXNzZnVsbHknKTtcbiAgfSxcbiAgKGVycm9yKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcignRmlyZWJhc2UgY29ubmVjdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgfVxuKTtcblxuLy8gQ29ubmVjdGlvbiBzdGF0dXMgY2hlY2sgZnVuY3Rpb25cbmNvbnN0IGNoZWNrQ29ubmVjdGlvbiA9IGFzeW5jICgpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgaWYgKCFpc0Nvbm5lY3RlZCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgYSBzaW1wbGUgcmVhZCBvcGVyYXRpb24gdG8gY2hlY2sgY29ubmVjdGlvblxuICAgICAgYXdhaXQgZ2V0RG9jKGNvbm5lY3Rpb25SZWYpO1xuICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBlc3RhYmxpc2ggY29ubmVjdGlvbjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gUmV0cnkgdXRpbGl0eSBmdW5jdGlvblxuY29uc3Qgd2l0aFJldHJ5ID0gYXN5bmMgPFQ+KFxuICBvcGVyYXRpb246ICgpID0+IFByb21pc2U8VD4sXG4gIG1heFJldHJpZXM6IG51bWJlciA9IDMsXG4gIGRlbGF5OiBudW1iZXIgPSAxMDAwXG4pOiBQcm9taXNlPFQ+ID0+IHtcbiAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcbiAgXG4gIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBjb25uZWN0aW9uIGJlZm9yZSBlYWNoIGF0dGVtcHRcbiAgICAgIGlmICghYXdhaXQgY2hlY2tDb25uZWN0aW9uKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb25uZWN0aW9uIHRvIEZpcmViYXNlJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZXJyb3IgYXMgRXJyb3I7XG4gICAgICBjb25zb2xlLndhcm4oYEF0dGVtcHQgJHthdHRlbXB0fSBmYWlsZWQ6YCwgZXJyb3IpO1xuICAgICAgXG4gICAgICBpZiAoYXR0ZW1wdCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICBjb25zdCBiYWNrb2ZmRGVsYXkgPSBkZWxheSAqIE1hdGgucG93KDIsIGF0dGVtcHQgLSAxKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGJhY2tvZmZEZWxheSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgdGhyb3cgbGFzdEVycm9yO1xufTtcblxuLy8gRW5oYW5jZWQgZXJyb3IgbG9nZ2luZ1xuY29uc3QgbG9nRXJyb3IgPSAob3BlcmF0aW9uOiBzdHJpbmcsIGVycm9yOiBhbnksIGNvbnRleHQ/OiBhbnkpID0+IHtcbiAgY29uc3QgZXJyb3JEZXRhaWxzID0ge1xuICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIG9wZXJhdGlvbixcbiAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHtcbiAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgICAgY29kZTogJ2NvZGUnIGluIGVycm9yID8gKGVycm9yIGFzIGFueSkuY29kZSA6IHVuZGVmaW5lZFxuICAgIH0gOiBlcnJvcixcbiAgICBjb250ZXh0LFxuICAgIGNvbm5lY3Rpb25TdGF0dXM6IGlzQ29ubmVjdGVkXG4gIH07XG4gIFxuICBjb25zb2xlLmVycm9yKCdGaXJlYmFzZSBPcGVyYXRpb24gRXJyb3I6JywgZXJyb3JEZXRhaWxzKTtcbiAgcmV0dXJuIGVycm9yRGV0YWlscztcbn07XG5cbmxldCBhbmFseXRpY3M7XG5cbnRyeSB7XG4gIC8vIEluaXRpYWxpemUgQW5hbHl0aWNzIG9ubHkgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhbmFseXRpY3MgPSBnZXRBbmFseXRpY3MoYXBwKTtcbiAgfVxuICBjb25zb2xlLmxvZygnRmlyZWJhc2UgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgRmlyZWJhc2U6JywgZXJyb3IpO1xuICB0aHJvdyBlcnJvcjtcbn1cblxuLy8gSW5pdGlhbGl6ZSBjb2xsZWN0aW9uc1xuZXhwb3J0IGNvbnN0IHN0b3JpZXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKTtcblxuZXhwb3J0IGludGVyZmFjZSBTdG9yeUNvbmZpZyB7XG4gIGluZHVzdHJ5OiBzdHJpbmc7XG4gIGNvbXBhbnlTaXplOiBzdHJpbmc7XG4gIHJvbGU6IHN0cmluZztcbiAgZXhwZXJpZW5jZTogc3RyaW5nO1xuICBmb2N1czogc3RyaW5nO1xuICB0b25lOiBzdHJpbmc7XG4gIGZvcm1hdDogc3RyaW5nO1xuICBsZW5ndGg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdG9yeSB7XG4gIGlkPzogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGNvbmZpZzogU3RvcnlDb25maWc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBzdGF0dXM6ICdjb21wbGV0ZWQnIHwgJ2luX3Byb2dyZXNzJyB8ICdmYWlsZWQnO1xuICBjcmVhdGVkQXQ6IFRpbWVzdGFtcDtcbiAgZXJyb3I/OiBTdG9yeUdlbmVyYXRpb25FcnJvcjtcbiAgZ2VuZXJhdGlvbkF0dGVtcHRzPzogbnVtYmVyO1xuICBsYXN0QXR0ZW1wdEF0PzogYW55O1xuICBzdG9yeVN0eWxlOiBzdHJpbmc7XG4gIGFjU3R5bGU6IHN0cmluZztcbn1cblxuLy8gQ3VzdG9tIGVycm9yIHR5cGVzIGZvciBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbmV4cG9ydCBjbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIGNvZGU6IHN0cmluZyxcbiAgICBwdWJsaWMgc3RhdHVzOiBudW1iZXIgPSA1MDBcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0ZpcmViYXNlRXJyb3InO1xuICB9XG59XG5cbi8vIEVuaGFuY2VkIHZhbGlkYXRpb24gZnVuY3Rpb25cbmNvbnN0IHZhbGlkYXRlU3RvcnkgPSAoc3Rvcnk6IE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0Jz4pID0+IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIFJlcXVpcmVkIGZpZWxkcyB2YWxpZGF0aW9uXG4gIGlmICghc3RvcnkudGl0bGU/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ1RpdGxlIGlzIHJlcXVpcmVkJyk7XG4gIGlmICghc3RvcnkuY29udGVudD8udHJpbSgpKSBlcnJvcnMucHVzaCgnQ29udGVudCBpcyByZXF1aXJlZCcpO1xuICBpZiAoIXN0b3J5LnVzZXJJZD8udHJpbSgpKSBlcnJvcnMucHVzaCgnVXNlciBJRCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIENvbmZpZyB2YWxpZGF0aW9uXG4gIGlmICghc3RvcnkuY29uZmlnKSB7XG4gICAgZXJyb3JzLnB1c2goJ0NvbmZpZ3VyYXRpb24gaXMgcmVxdWlyZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGZvY3VzLCB0b25lLCBmb3JtYXQsIGxlbmd0aCB9ID0gc3RvcnkuY29uZmlnO1xuICAgIGlmICghZm9jdXM/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0ZvY3VzIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCF0b25lPy50cmltKCkpIGVycm9ycy5wdXNoKCdUb25lIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCFmb3JtYXQ/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0Zvcm1hdCBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghbGVuZ3RoPy50cmltKCkpIGVycm9ycy5wdXNoKCdMZW5ndGggaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIC8vIFN0YXR1cyB2YWxpZGF0aW9uXG4gIGlmICghc3Rvcnkuc3RhdHVzIHx8ICFbJ2NvbXBsZXRlZCcsICdpbl9wcm9ncmVzcycsICdmYWlsZWQnXS5pbmNsdWRlcyhzdG9yeS5zdGF0dXMpKSB7XG4gICAgZXJyb3JzLnB1c2goJ0ludmFsaWQgc3RhdHVzJyk7XG4gIH1cblxuICAvLyBDb250ZW50IGxlbmd0aCB2YWxpZGF0aW9uXG4gIGlmIChzdG9yeS5jb250ZW50Lmxlbmd0aCA8IDUwKSB7XG4gICAgZXJyb3JzLnB1c2goJ0NvbnRlbnQgbXVzdCBiZSBhdCBsZWFzdCA1MCBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgfVxuXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKGVycm9ycy5qb2luKCcsICcpLCAnSU5WQUxJRF9EQVRBJywgNDAwKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gZ2V0IHN0b3JpZXMgZm9yIHRoZSBjdXJyZW50IHVzZXJcbmV4cG9ydCBjb25zdCBnZXRTdG9yaWVzID0gYXN5bmMgKCkgPT4ge1xuICByZXR1cm4gd2l0aFJldHJ5KGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGZldGNoIHN0b3JpZXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcSA9IHF1ZXJ5KFxuICAgICAgICBzdG9yaWVzQ29sbGVjdGlvbixcbiAgICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXIudWlkKSxcbiAgICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MocSk7XG4gICAgICByZXR1cm4gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgLi4uZG9jLmRhdGEoKVxuICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dFcnJvcignZ2V0U3RvcmllcycsIGVycm9yLCB7IHVzZXJJZDogYXV0aC5jdXJyZW50VXNlcj8udWlkIH0pO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgICAnRmFpbGVkIHRvIGZldGNoIHN0b3JpZXMuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyxcbiAgICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgICAgNTAwXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBGdW5jdGlvbiB0byBzYXZlIGEgc3RvcnkgdG8gRmlyZXN0b3JlXG5leHBvcnQgY29uc3Qgc2F2ZVN0b3J5ID0gYXN5bmMgKHN0b3J5OiBPbWl0PFN0b3J5LCAnaWQnIHwgJ2NyZWF0ZWRBdCc+KTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgcmV0dXJuIHdpdGhSZXRyeShhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byBzYXZlIHN0b3JpZXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGVTdG9yeShzdG9yeSk7XG5cbiAgICAgIGNvbnN0IHN0b3J5RGF0YSA9IHtcbiAgICAgICAgLi4uc3RvcnksXG4gICAgICAgIHVzZXJJZDogdXNlci51aWQsXG4gICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcgYXMgY29uc3QsXG4gICAgICAgIGdlbmVyYXRpb25BdHRlbXB0czogMCxcbiAgICAgICAgbGFzdEF0dGVtcHRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhzdG9yaWVzQ29sbGVjdGlvbiwgc3RvcnlEYXRhKTtcbiAgICAgIHJldHVybiBkb2NSZWYuaWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ0Vycm9yKCdzYXZlU3RvcnknLCBlcnJvciwgeyBcbiAgICAgICAgdXNlcklkOiBhdXRoLmN1cnJlbnRVc2VyPy51aWQsXG4gICAgICAgIHN0b3J5VGl0bGU6IHN0b3J5LnRpdGxlLFxuICAgICAgICBzdG9yeUNvbmZpZzogc3RvcnkuY29uZmlnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiBlcnJvcikge1xuICAgICAgICAgIGNvbnN0IGZpcmViYXNlRXJyb3IgPSBlcnJvciBhcyB7IGNvZGU6IHN0cmluZzsgbWVzc2FnZTogc3RyaW5nIH07XG4gICAgICAgICAgc3dpdGNoIChmaXJlYmFzZUVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Blcm1pc3Npb24tZGVuaWVkJzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1Blcm1pc3Npb24gZGVuaWVkLiBQbGVhc2UgY2hlY2sgeW91ciBhdXRoZW50aWNhdGlvbiBzdGF0dXMuJywgJ1BFUk1JU1NJT05fREVOSUVEJywgNDAzKTtcbiAgICAgICAgICAgIGNhc2UgJ3VuYXV0aGVudGljYXRlZCc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdQbGVhc2Ugc2lnbiBpbiB0byBzYXZlIHN0b3JpZXMuJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgICAgICAgICBjYXNlICdpbnZhbGlkLWFyZ3VtZW50JzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ0ludmFsaWQgc3RvcnkgZGF0YSBwcm92aWRlZC4nLCAnSU5WQUxJRF9EQVRBJywgNDAwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdGYWlsZWQgdG8gc2F2ZSBzdG9yeS4gUGxlYXNlIHRyeSBhZ2Fpbi4nLCAnU0FWRV9FUlJPUicsIDUwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgICAnRmFpbGVkIHRvIHNhdmUgc3RvcnkuIFBsZWFzZSB0cnkgYWdhaW4uJyxcbiAgICAgICAgJ1NBVkVfRVJST1InLFxuICAgICAgICA1MDBcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBhIHN0b3J5XG5leHBvcnQgY29uc3QgdXBkYXRlU3RvcnkgPSBhc3luYyAoc3RvcnlJZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0JyB8ICd1c2VySWQnPj4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byB1cGRhdGUgc3RvcmllcycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgZXhpc3Rpbmcgc3RvcnkgdG8gdmVyaWZ5IG93bmVyc2hpcFxuICAgIGNvbnN0IHN0b3J5UmVmID0gZG9jKGRiLCAnc3RvcmllcycsIHN0b3J5SWQpO1xuICAgIGNvbnN0IHN0b3J5U25hcCA9IGF3YWl0IGdldERvYyhzdG9yeVJlZik7XG5cbiAgICBpZiAoIXN0b3J5U25hcC5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1N0b3J5IG5vdCBmb3VuZCcsICdOT1RfRk9VTkQnLCA0MDQpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3J5RGF0YSA9IHN0b3J5U25hcC5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIHVwZGF0ZSB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHVwZGF0ZWQgZGF0YVxuICAgIGNvbnN0IHVwZGF0ZWRTdG9yeSA9IHsgLi4uc3RvcnlEYXRhLCAuLi51cGRhdGVzIH07XG4gICAgdmFsaWRhdGVTdG9yeSh1cGRhdGVkU3RvcnkpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzdG9yeVxuICAgIGF3YWl0IHVwZGF0ZURvYyhzdG9yeVJlZiwge1xuICAgICAgLi4udXBkYXRlcyxcbiAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RvcnlJZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgc3Rvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byB1cGRhdGUgc3RvcnknLFxuICAgICAgJ1VQREFURV9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIGdldCBhIHNpbmdsZSBzdG9yeVxuZXhwb3J0IGNvbnN0IGdldFN0b3J5ID0gYXN5bmMgKHN0b3J5SWQ6IHN0cmluZyk6IFByb21pc2U8U3RvcnkgfCBudWxsPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gZ2V0IHN0b3JpZXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yeURvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICdzdG9yaWVzJywgc3RvcnlJZCkpO1xuICAgIGlmICghc3RvcnlEb2MuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdTdG9yeSBub3QgZm91bmQnLCAnTk9UX0ZPVU5EJywgNDA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yeURhdGEgPSBzdG9yeURvYy5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzdG9yeURvYy5pZCxcbiAgICAgIC4uLnN0b3J5RGF0YVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc3Rvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byBnZXQgc3RvcnknLFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gQWRkIG5ldyBlcnJvciB0eXBlcyBmb3Igc3RvcnkgZ2VuZXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBTdG9yeUdlbmVyYXRpb25FcnJvciB7XG4gIGNvZGU6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkZXRhaWxzPzogYW55O1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIHJldHJ5Q291bnQ/OiBudW1iZXI7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0b3J5IHdpdGggaW5pdGlhbCBzdGF0dXMgYW5kIGVycm9yIHRyYWNraW5nXG5leHBvcnQgY29uc3QgY3JlYXRlU3RvcnlXaXRoU3RhdHVzID0gYXN5bmMgKFxuICBzdG9yeTogT21pdDxTdG9yeSwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3N0YXR1cyc+LFxuICBzdGF0dXM6ICdpbl9wcm9ncmVzcycgfCAnZmFpbGVkJyA9ICdpbl9wcm9ncmVzcycsXG4gIGVycm9yPzogU3RvcnlHZW5lcmF0aW9uRXJyb3JcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGNyZWF0ZSBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGluaXRpYWwgc3RvcnkgZG9jdW1lbnQgd2l0aCBlcnJvciB0cmFja2luZ1xuICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhzdG9yaWVzQ29sbGVjdGlvbiwge1xuICAgICAgLi4uc3RvcnksXG4gICAgICB1c2VySWQ6IHVzZXIudWlkLFxuICAgICAgc3RhdHVzLFxuICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGVycm9yOiBlcnJvciA/IHtcbiAgICAgICAgLi4uZXJyb3IsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9IDogbnVsbCxcbiAgICAgIGdlbmVyYXRpb25BdHRlbXB0czogMCxcbiAgICAgIGxhc3RBdHRlbXB0QXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZG9jUmVmLmlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzdG9yeTonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoXG4gICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBzdG9yeScsXG4gICAgICAnQ1JFQVRFX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHN0b3J5IGdlbmVyYXRpb24gc3RhdHVzIHdpdGggZGV0YWlsZWQgZXJyb3IgdHJhY2tpbmdcbmV4cG9ydCBjb25zdCB1cGRhdGVTdG9yeVN0YXR1cyA9IGFzeW5jIChcbiAgc3RvcnlJZDogc3RyaW5nLFxuICBzdGF0dXM6ICdjb21wbGV0ZWQnIHwgJ2luX3Byb2dyZXNzJyB8ICdmYWlsZWQnLFxuICBlcnJvcj86IFN0b3J5R2VuZXJhdGlvbkVycm9yXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byB1cGRhdGUgc3Rvcnkgc3RhdHVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlSZWYgPSBkb2MoZGIsICdzdG9yaWVzJywgc3RvcnlJZCk7XG4gICAgY29uc3Qgc3RvcnlTbmFwID0gYXdhaXQgZ2V0RG9jKHN0b3J5UmVmKTtcblxuICAgIGlmICghc3RvcnlTbmFwLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignU3Rvcnkgbm90IGZvdW5kJywgJ05PVF9GT1VORCcsIDQwNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEYXRhID0gc3RvcnlTbmFwLmRhdGEoKSBhcyBTdG9yeTtcbiAgICBpZiAoc3RvcnlEYXRhLnVzZXJJZCAhPT0gdXNlci51aWQpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVbmF1dGhvcml6ZWQgdG8gdXBkYXRlIHRoaXMgc3RvcnknLCAnVU5BVVRIT1JJWkVEJywgNDAzKTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVzOiBhbnkgPSB7XG4gICAgICBzdGF0dXMsXG4gICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgbGFzdEF0dGVtcHRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICB9O1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB1cGRhdGVzLmVycm9yID0ge1xuICAgICAgICAuLi5lcnJvcixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICB1cGRhdGVzLmdlbmVyYXRpb25BdHRlbXB0cyA9IChzdG9yeURhdGEuZ2VuZXJhdGlvbkF0dGVtcHRzIHx8IDApICsgMTtcbiAgICB9XG5cbiAgICBhd2FpdCB1cGRhdGVEb2Moc3RvcnlSZWYsIHVwZGF0ZXMpO1xuICAgIHJldHVybiBzdG9yeUlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzdG9yeSBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byB1cGRhdGUgc3Rvcnkgc3RhdHVzJyxcbiAgICAgICdVUERBVEVfRVJST1InLFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IgPyA1MDAgOiA1MDBcbiAgICApO1xuICB9XG59O1xuXG4vLyBGdW5jdGlvbiB0byBnZXQgc3RvcnkgZ2VuZXJhdGlvbiBzdGF0dXNcbmV4cG9ydCBjb25zdCBnZXRTdG9yeUdlbmVyYXRpb25TdGF0dXMgPSBhc3luYyAoc3RvcnlJZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gZ2V0IHN0b3J5IHN0YXR1cycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiwgJ3N0b3JpZXMnLCBzdG9yeUlkKTtcbiAgICBjb25zdCBkb2NTbmFwID0gYXdhaXQgZ2V0RG9jKGRvY1JlZik7XG5cbiAgICBpZiAoIWRvY1NuYXAuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdTdG9yeSBub3QgZm91bmQnLCAnTk9UX0ZPVU5EJywgNDA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yeURhdGEgPSBkb2NTbmFwLmRhdGEoKSBhcyBTdG9yeTtcbiAgICBpZiAoc3RvcnlEYXRhLnVzZXJJZCAhPT0gdXNlci51aWQpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVbmF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgc3RvcnknLCAnVU5BVVRIT1JJWkVEJywgNDAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBzdG9yeURhdGEuc3RhdHVzLFxuICAgICAgZXJyb3I6IHN0b3J5RGF0YS5lcnJvcixcbiAgICAgIGdlbmVyYXRpb25BdHRlbXB0czogc3RvcnlEYXRhLmdlbmVyYXRpb25BdHRlbXB0cyB8fCAwLFxuICAgICAgbGFzdEF0dGVtcHRBdDogc3RvcnlEYXRhLmxhc3RBdHRlbXB0QXRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0b3J5IHN0YXR1czonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoXG4gICAgICAnRmFpbGVkIHRvIGdldCBzdG9yeSBzdGF0dXMnLFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gQmF0Y2ggb3BlcmF0aW9uc1xuZXhwb3J0IGNvbnN0IGJhdGNoU2F2ZVN0b3JpZXMgPSBhc3luYyAoc3RvcmllczogT21pdDxTdG9yeSwgJ2lkJyB8ICdjcmVhdGVkQXQnPltdKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhdGNoID0gd3JpdGVCYXRjaChkYik7XG4gICAgY29uc3Qgc3RvcnlJZHM6IHN0cmluZ1tdID0gW107XG5cbiAgICBzdG9yaWVzLmZvckVhY2goc3RvcnkgPT4ge1xuICAgICAgdmFsaWRhdGVTdG9yeShzdG9yeSk7XG4gICAgICBjb25zdCBzdG9yeVJlZiA9IGRvYyhjb2xsZWN0aW9uKGRiLCAnc3RvcmllcycpKTtcbiAgICAgIGJhdGNoLnNldChzdG9yeVJlZiwge1xuICAgICAgICAuLi5zdG9yeSxcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyBhcyBjb25zdFxuICAgICAgfSk7XG4gICAgICBzdG9yeUlkcy5wdXNoKHN0b3J5UmVmLmlkKTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGJhdGNoLmNvbW1pdCgpO1xuICAgIHJldHVybiBzdG9yeUlkcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBiYXRjaCBzYXZpbmcgc3RvcmllczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYmF0Y2ggc2F2ZSBzdG9yaWVzJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBiYXRjaERlbGV0ZVN0b3JpZXMgPSBhc3luYyAoc3RvcnlJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYmF0Y2ggPSB3cml0ZUJhdGNoKGRiKTtcbiAgICBcbiAgICBzdG9yeUlkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGNvbnN0IHN0b3J5UmVmID0gZG9jKGRiLCAnc3RvcmllcycsIGlkKTtcbiAgICAgIGJhdGNoLmRlbGV0ZShzdG9yeVJlZik7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBiYXRjaC5jb21taXQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBiYXRjaCBkZWxldGluZyBzdG9yaWVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBiYXRjaCBkZWxldGUgc3RvcmllcycpO1xuICB9XG59O1xuXG4vLyBQYWdpbmF0aW9uIHN1cHBvcnRcbmV4cG9ydCBjb25zdCBnZXRTdG9yaWVzUGFnaW5hdGVkID0gYXN5bmMgKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgcGFnZVNpemU6IG51bWJlciA9IDEwLFxuICBsYXN0RG9jPzogRG9jdW1lbnRTbmFwc2hvdFxuKTogUHJvbWlzZTx7IHN0b3JpZXM6IFN0b3J5W107IGxhc3REb2M6IERvY3VtZW50U25hcHNob3QgfCBudWxsIH0+ID0+IHtcbiAgdHJ5IHtcbiAgICBsZXQgcSA9IHF1ZXJ5KFxuICAgICAgY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKSxcbiAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxuICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKSxcbiAgICAgIGxpbWl0KHBhZ2VTaXplKVxuICAgICk7XG5cbiAgICBpZiAobGFzdERvYykge1xuICAgICAgcSA9IHF1ZXJ5KHEsIHN0YXJ0QWZ0ZXIobGFzdERvYykpO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIGNvbnN0IHN0b3JpZXMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmRvYy5kYXRhKClcbiAgICB9IGFzIFN0b3J5KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmllcyxcbiAgICAgIGxhc3REb2M6IHF1ZXJ5U25hcHNob3QuZG9jc1txdWVyeVNuYXBzaG90LmRvY3MubGVuZ3RoIC0gMV0gfHwgbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwYWdpbmF0ZWQgc3RvcmllczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHBhZ2luYXRlZCBzdG9yaWVzJyk7XG4gIH1cbn07XG5cbi8vIFNlYXJjaCBzdG9yaWVzXG5leHBvcnQgY29uc3Qgc2VhcmNoU3RvcmllcyA9IGFzeW5jIChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHNlYXJjaFRlcm06IHN0cmluZ1xuKTogUHJvbWlzZTxTdG9yeVtdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3Rvcmllc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICBjb2xsZWN0aW9uKGRiLCAnc3RvcmllcycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhzdG9yaWVzUXVlcnkpO1xuICAgIGNvbnN0IHN0b3JpZXMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmRvYy5kYXRhKClcbiAgICB9IGFzIFN0b3J5KSk7XG5cbiAgICAvLyBDbGllbnQtc2lkZSBzZWFyY2ggZm9yIGJldHRlciBmbGV4aWJpbGl0eVxuICAgIHJldHVybiBzdG9yaWVzLmZpbHRlcihzdG9yeSA9PiBcbiAgICAgIHN0b3J5LnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgc3RvcnkuY29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgIHN0b3J5LmNvbmZpZy5mb2N1cy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgIHN0b3J5LmNvbmZpZy50b25lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpKVxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIHN0b3JpZXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNlYXJjaCBzdG9yaWVzJyk7XG4gIH1cbn07XG5cbi8vIFN0b3J5IHN0YXRpc3RpY3NcbmV4cG9ydCBjb25zdCBnZXRTdG9yeVN0YXRzID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx7XG4gIHRvdGFsOiBudW1iZXI7XG4gIGNvbXBsZXRlZDogbnVtYmVyO1xuICBpblByb2dyZXNzOiBudW1iZXI7XG4gIGZhaWxlZDogbnVtYmVyO1xuICBieUZvY3VzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICBieVRvbmU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG59PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3Rvcmllc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICBjb2xsZWN0aW9uKGRiLCAnc3RvcmllcycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZClcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHN0b3JpZXNRdWVyeSk7XG4gICAgY29uc3Qgc3RvcmllcyA9IHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+IGRvYy5kYXRhKCkgYXMgU3RvcnkpO1xuXG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICB0b3RhbDogc3Rvcmllcy5sZW5ndGgsXG4gICAgICBjb21wbGV0ZWQ6IDAsXG4gICAgICBpblByb2dyZXNzOiAwLFxuICAgICAgZmFpbGVkOiAwLFxuICAgICAgYnlGb2N1czoge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICAgIGJ5VG9uZToge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPlxuICAgIH07XG5cbiAgICBzdG9yaWVzLmZvckVhY2goc3RvcnkgPT4ge1xuICAgICAgLy8gQ291bnQgYnkgc3RhdHVzXG4gICAgICBzdGF0c1tzdG9yeS5zdGF0dXNdKys7XG4gICAgICBcbiAgICAgIC8vIENvdW50IGJ5IGZvY3VzXG4gICAgICBzdGF0cy5ieUZvY3VzW3N0b3J5LmNvbmZpZy5mb2N1c10gPSAoc3RhdHMuYnlGb2N1c1tzdG9yeS5jb25maWcuZm9jdXNdIHx8IDApICsgMTtcbiAgICAgIFxuICAgICAgLy8gQ291bnQgYnkgdG9uZVxuICAgICAgc3RhdHMuYnlUb25lW3N0b3J5LmNvbmZpZy50b25lXSA9IChzdGF0cy5ieVRvbmVbc3RvcnkuY29uZmlnLnRvbmVdIHx8IDApICsgMTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdGF0cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0b3J5IHN0YXRzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgc3Rvcnkgc3RhdGlzdGljcycpO1xuICB9XG59O1xuXG5leHBvcnQgeyBhcHAsIGF1dGgsIGRiLCBhbmFseXRpY3MgfTsgIl0sIm5hbWVzIjpbImluaXRpYWxpemVBcHAiLCJnZXRBcHBzIiwiZ2V0QXBwIiwiZ2V0QXV0aCIsImdldEZpcmVzdG9yZSIsImNvbGxlY3Rpb24iLCJhZGREb2MiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJxdWVyeSIsIndoZXJlIiwib3JkZXJCeSIsImdldERvY3MiLCJkb2MiLCJnZXREb2MiLCJ1cGRhdGVEb2MiLCJ3cml0ZUJhdGNoIiwibGltaXQiLCJzdGFydEFmdGVyIiwib25TbmFwc2hvdCIsImVuYWJsZUluZGV4ZWREYlBlcnNpc3RlbmNlIiwiZ2V0QW5hbHl0aWNzIiwiY29uc29sZSIsImxvZyIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZIiwiYXV0aERvbWFpbiIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOIiwicHJvamVjdElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCIsInN0b3JhZ2VCdWNrZXQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9TVE9SQUdFX0JVQ0tFVCIsIm1lc3NhZ2luZ1NlbmRlcklkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVTU0FHSU5HX1NFTkRFUl9JRCIsImFwcElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lEIiwibWVhc3VyZW1lbnRJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FQVNVUkVNRU5UX0lEIiwiZmlyZWJhc2VDb25maWciLCJpc0Nvbm5lY3RlZCIsImFwcCIsImxlbmd0aCIsImF1dGgiLCJkYiIsImNhdGNoIiwiZXJyIiwiY29kZSIsIndhcm4iLCJjb25uZWN0aW9uUmVmIiwiZXJyb3IiLCJjaGVja0Nvbm5lY3Rpb24iLCJ3aXRoUmV0cnkiLCJvcGVyYXRpb24iLCJtYXhSZXRyaWVzIiwiZGVsYXkiLCJsYXN0RXJyb3IiLCJhdHRlbXB0IiwiRXJyb3IiLCJiYWNrb2ZmRGVsYXkiLCJNYXRoIiwicG93IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibG9nRXJyb3IiLCJjb250ZXh0IiwiZXJyb3JEZXRhaWxzIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibmFtZSIsIm1lc3NhZ2UiLCJzdGFjayIsInVuZGVmaW5lZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJhbmFseXRpY3MiLCJzdG9yaWVzQ29sbGVjdGlvbiIsIkZpcmViYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0YXR1cyIsInZhbGlkYXRlU3RvcnkiLCJzdG9yeSIsImVycm9ycyIsInRpdGxlIiwidHJpbSIsInB1c2giLCJjb250ZW50IiwidXNlcklkIiwiY29uZmlnIiwiZm9jdXMiLCJ0b25lIiwiZm9ybWF0IiwiaW5jbHVkZXMiLCJqb2luIiwiZ2V0U3RvcmllcyIsInVzZXIiLCJjdXJyZW50VXNlciIsInEiLCJ1aWQiLCJxdWVyeVNuYXBzaG90IiwiZG9jcyIsIm1hcCIsImlkIiwiZGF0YSIsInNhdmVTdG9yeSIsInN0b3J5RGF0YSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImdlbmVyYXRpb25BdHRlbXB0cyIsImxhc3RBdHRlbXB0QXQiLCJkb2NSZWYiLCJzdG9yeVRpdGxlIiwic3RvcnlDb25maWciLCJmaXJlYmFzZUVycm9yIiwidXBkYXRlU3RvcnkiLCJzdG9yeUlkIiwidXBkYXRlcyIsInN0b3J5UmVmIiwic3RvcnlTbmFwIiwiZXhpc3RzIiwidXBkYXRlZFN0b3J5IiwiZ2V0U3RvcnkiLCJzdG9yeURvYyIsImNyZWF0ZVN0b3J5V2l0aFN0YXR1cyIsInVwZGF0ZVN0b3J5U3RhdHVzIiwiZ2V0U3RvcnlHZW5lcmF0aW9uU3RhdHVzIiwiZG9jU25hcCIsImJhdGNoU2F2ZVN0b3JpZXMiLCJzdG9yaWVzIiwiYmF0Y2giLCJzdG9yeUlkcyIsImZvckVhY2giLCJzZXQiLCJjb21taXQiLCJiYXRjaERlbGV0ZVN0b3JpZXMiLCJkZWxldGUiLCJnZXRTdG9yaWVzUGFnaW5hdGVkIiwicGFnZVNpemUiLCJsYXN0RG9jIiwic2VhcmNoU3RvcmllcyIsInNlYXJjaFRlcm0iLCJzdG9yaWVzUXVlcnkiLCJmaWx0ZXIiLCJ0b0xvd2VyQ2FzZSIsImdldFN0b3J5U3RhdHMiLCJzdGF0cyIsInRvdGFsIiwiY29tcGxldGVkIiwiaW5Qcm9ncmVzcyIsImZhaWxlZCIsImJ5Rm9jdXMiLCJieVRvbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firebase.ts\n"));

/***/ })

});