"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/generate/page",{

/***/ "(app-pages-browser)/./src/lib/firebase.ts":
/*!*****************************!*\
  !*** ./src/lib/firebase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: function() { return /* binding */ FirebaseError; },\n/* harmony export */   analytics: function() { return /* binding */ analytics; },\n/* harmony export */   app: function() { return /* binding */ app; },\n/* harmony export */   auth: function() { return /* binding */ auth; },\n/* harmony export */   batchDeleteStories: function() { return /* binding */ batchDeleteStories; },\n/* harmony export */   batchSaveStories: function() { return /* binding */ batchSaveStories; },\n/* harmony export */   createStoryWithStatus: function() { return /* binding */ createStoryWithStatus; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   getStories: function() { return /* binding */ getStories; },\n/* harmony export */   getStoriesPaginated: function() { return /* binding */ getStoriesPaginated; },\n/* harmony export */   getStory: function() { return /* binding */ getStory; },\n/* harmony export */   getStoryGenerationStatus: function() { return /* binding */ getStoryGenerationStatus; },\n/* harmony export */   getStoryStats: function() { return /* binding */ getStoryStats; },\n/* harmony export */   saveStory: function() { return /* binding */ saveStory; },\n/* harmony export */   searchStories: function() { return /* binding */ searchStories; },\n/* harmony export */   storiesCollection: function() { return /* binding */ storiesCollection; },\n/* harmony export */   updateStory: function() { return /* binding */ updateStory; },\n/* harmony export */   updateStoryStatus: function() { return /* binding */ updateStoryStatus; }\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_analytics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/analytics */ \"(app-pages-browser)/./node_modules/firebase/analytics/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ storiesCollection,FirebaseError,getStories,saveStory,updateStory,getStory,createStoryWithStatus,updateStoryStatus,getStoryGenerationStatus,batchSaveStories,batchDeleteStories,getStoriesPaginated,searchStories,getStoryStats,app,auth,db,analytics auto */ \n\n\n\n// Log environment variables for debugging\nconsole.log(\"Firebase Config:\", {\n    apiKey:  true ? \"Set\" : 0,\n    authDomain:  true ? \"Set\" : 0,\n    projectId:  true ? \"Set\" : 0,\n    storageBucket:  true ? \"Set\" : 0,\n    messagingSenderId:  true ? \"Set\" : 0,\n    appId:  true ? \"Set\" : 0,\n    measurementId:  true ? \"Set\" : 0\n});\nconst firebaseConfig = {\n    apiKey: \"AIzaSyAPjxc_Y70cfxyME-ao3WspK8PCeJaTR7k\",\n    authDomain: \"montajai.firebaseapp.com\",\n    projectId: \"montajai\",\n    storageBucket: \"montajai.firebasestorage.app\",\n    messagingSenderId: \"1074834137884\",\n    appId: \"1:1074834137884:web:acaa300a37b9dadc3e10d9\",\n    measurementId: \"G-HSZ6LZR8Q9\"\n};\n// Add connection status tracking\nlet isConnected = false;\n// Initialize Firebase with connection monitoring\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)() : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)(app);\n// Monitor connection status using onSnapshot\nconst connectionRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"_health\", \"connection\");\n(0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.onSnapshot)(connectionRef, ()=>{\n    isConnected = true;\n    console.log(\"Firebase connected successfully\");\n}, (error)=>{\n    console.error(\"Firebase connection error:\", error);\n    isConnected = false;\n});\n// Connection status check function\nconst checkConnection = async ()=>{\n    if (!isConnected) {\n        try {\n            // Try a simple read operation to check connection\n            await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(connectionRef);\n            isConnected = true;\n            return true;\n        } catch (error) {\n            console.error(\"Failed to establish connection:\", error);\n            return false;\n        }\n    }\n    return true;\n};\n// Retry utility function\nconst withRetry = async function(operation) {\n    let maxRetries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, delay = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1000;\n    let lastError = null;\n    for(let attempt = 1; attempt <= maxRetries; attempt++){\n        try {\n            // Check connection before each attempt\n            if (!await checkConnection()) {\n                throw new Error(\"No connection to Firebase\");\n            }\n            return await operation();\n        } catch (error) {\n            lastError = error;\n            console.warn(\"Attempt \".concat(attempt, \" failed:\"), error);\n            if (attempt < maxRetries) {\n                // Exponential backoff\n                const backoffDelay = delay * Math.pow(2, attempt - 1);\n                await new Promise((resolve)=>setTimeout(resolve, backoffDelay));\n            }\n        }\n    }\n    throw lastError;\n};\n// Enhanced error logging\nconst logError = (operation, error, context)=>{\n    const errorDetails = {\n        timestamp: new Date().toISOString(),\n        operation,\n        error: error instanceof Error ? {\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n            code: \"code\" in error ? error.code : undefined\n        } : error,\n        context,\n        connectionStatus: isConnected\n    };\n    console.error(\"Firebase Operation Error:\", errorDetails);\n    return errorDetails;\n};\nlet analytics;\ntry {\n    // Initialize Analytics only in browser environment\n    if (true) {\n        analytics = (0,firebase_analytics__WEBPACK_IMPORTED_MODULE_3__.getAnalytics)(app);\n    }\n    console.log(\"Firebase initialized successfully\");\n} catch (error) {\n    console.error(\"Error initializing Firebase:\", error);\n    throw error;\n}\n// Initialize collections\nconst storiesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\");\n// Custom error types for better error handling\nclass FirebaseError extends Error {\n    constructor(message, code, status = 500){\n        super(message);\n        this.code = code;\n        this.status = status;\n        this.name = \"FirebaseError\";\n    }\n}\n// Enhanced validation function\nconst validateStory = (story)=>{\n    var _story_title, _story_content, _story_userId;\n    const errors = [];\n    // Required fields validation\n    if (!((_story_title = story.title) === null || _story_title === void 0 ? void 0 : _story_title.trim())) errors.push(\"Title is required\");\n    if (!((_story_content = story.content) === null || _story_content === void 0 ? void 0 : _story_content.trim())) errors.push(\"Content is required\");\n    if (!((_story_userId = story.userId) === null || _story_userId === void 0 ? void 0 : _story_userId.trim())) errors.push(\"User ID is required\");\n    // Config validation\n    if (!story.config) {\n        errors.push(\"Configuration is required\");\n    } else {\n        const { focus, tone, format, length } = story.config;\n        if (!(focus === null || focus === void 0 ? void 0 : focus.trim())) errors.push(\"Focus is required\");\n        if (!(tone === null || tone === void 0 ? void 0 : tone.trim())) errors.push(\"Tone is required\");\n        if (!(format === null || format === void 0 ? void 0 : format.trim())) errors.push(\"Format is required\");\n        if (!(length === null || length === void 0 ? void 0 : length.trim())) errors.push(\"Length is required\");\n    }\n    // Status validation\n    if (!story.status || ![\n        \"completed\",\n        \"in_progress\",\n        \"failed\"\n    ].includes(story.status)) {\n        errors.push(\"Invalid status\");\n    }\n    // Content length validation\n    if (story.content.length < 50) {\n        errors.push(\"Content must be at least 50 characters long\");\n    }\n    if (errors.length > 0) {\n        throw new FirebaseError(errors.join(\", \"), \"INVALID_DATA\", 400);\n    }\n};\n// Function to get stories for the current user\nconst getStories = async ()=>{\n    return withRetry(async ()=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) {\n                throw new FirebaseError(\"User must be authenticated to fetch stories\", \"UNAUTHENTICATED\", 401);\n            }\n            const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(storiesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", user.uid), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"));\n            const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n            return querySnapshot.docs.map((doc)=>({\n                    id: doc.id,\n                    ...doc.data()\n                }));\n        } catch (error) {\n            var _auth_currentUser;\n            logError(\"getStories\", error, {\n                userId: (_auth_currentUser = auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.uid\n            });\n            if (error instanceof FirebaseError) {\n                throw error;\n            }\n            throw new FirebaseError(\"Failed to fetch stories. Please try again later.\", \"FETCH_ERROR\", 500);\n        }\n    });\n};\n// Function to save a story to Firestore\nconst saveStory = async (story)=>{\n    return withRetry(async ()=>{\n        try {\n            const user = auth.currentUser;\n            if (!user) {\n                throw new FirebaseError(\"User must be authenticated to save stories\", \"UNAUTHENTICATED\", 401);\n            }\n            validateStory(story);\n            const storyData = {\n                ...story,\n                userId: user.uid,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n                status: \"completed\",\n                generationAttempts: 0,\n                lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n            };\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)(storiesCollection, storyData);\n            return docRef.id;\n        } catch (error) {\n            var _auth_currentUser;\n            logError(\"saveStory\", error, {\n                userId: (_auth_currentUser = auth.currentUser) === null || _auth_currentUser === void 0 ? void 0 : _auth_currentUser.uid,\n                storyTitle: story.title,\n                storyConfig: story.config\n            });\n            if (error instanceof Error) {\n                if (\"code\" in error) {\n                    const firebaseError = error;\n                    switch(firebaseError.code){\n                        case \"permission-denied\":\n                            throw new FirebaseError(\"Permission denied. Please check your authentication status.\", \"PERMISSION_DENIED\", 403);\n                        case \"unauthenticated\":\n                            throw new FirebaseError(\"Please sign in to save stories.\", \"UNAUTHENTICATED\", 401);\n                        case \"invalid-argument\":\n                            throw new FirebaseError(\"Invalid story data provided.\", \"INVALID_DATA\", 400);\n                        default:\n                            throw new FirebaseError(\"Failed to save story. Please try again.\", \"SAVE_ERROR\", 500);\n                    }\n                }\n            }\n            throw new FirebaseError(\"Failed to save story. Please try again.\", \"SAVE_ERROR\", 500);\n        }\n    });\n};\n// Function to update a story\nconst updateStory = async (storyId, updates)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Get the existing story to verify ownership\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        // Validate the updated data\n        const updatedStory = {\n            ...storyData,\n            ...updates\n        };\n        validateStory(updatedStory);\n        // Update the story\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, {\n            ...updates,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story:\", error);\n        throw new FirebaseError(\"Failed to update story\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get a single story\nconst getStory = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get stories\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId));\n        if (!storyDoc.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storyDoc.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            id: storyDoc.id,\n            ...storyData\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story:\", error);\n        throw new FirebaseError(\"Failed to get story\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to create a story with initial status and error tracking\nconst createStoryWithStatus = async function(story) {\n    let status = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"in_progress\", error = arguments.length > 2 ? arguments[2] : void 0;\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to create stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Create initial story document with error tracking\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)(storiesCollection, {\n            ...story,\n            userId: user.uid,\n            status,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            error: error ? {\n                ...error,\n                timestamp: new Date().toISOString()\n            } : null,\n            generationAttempts: 0,\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return docRef.id;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error creating story:\", error);\n        throw new FirebaseError(\"Failed to create story\", \"CREATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to update story generation status with detailed error tracking\nconst updateStoryStatus = async (storyId, status, error)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        const updates = {\n            status,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        };\n        if (error) {\n            updates.error = {\n                ...error,\n                timestamp: new Date().toISOString()\n            };\n            updates.generationAttempts = (storyData.generationAttempts || 0) + 1;\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, updates);\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story status:\", error);\n        throw new FirebaseError(\"Failed to update story status\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get story generation status\nconst getStoryGenerationStatus = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(docRef);\n        if (!docSnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = docSnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            status: storyData.status,\n            error: storyData.error,\n            generationAttempts: storyData.generationAttempts || 0,\n            lastAttemptAt: storyData.lastAttemptAt\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story status:\", error);\n        throw new FirebaseError(\"Failed to get story status\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Batch operations\nconst batchSaveStories = async (stories)=>{\n    try {\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.writeBatch)(db);\n        const storyIds = [];\n        stories.forEach((story)=>{\n            validateStory(story);\n            const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"));\n            batch.set(storyRef, {\n                ...story,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n                status: \"completed\"\n            });\n            storyIds.push(storyRef.id);\n        });\n        await batch.commit();\n        return storyIds;\n    } catch (error) {\n        console.error(\"Error batch saving stories:\", error);\n        throw new Error(\"Failed to batch save stories\");\n    }\n};\nconst batchDeleteStories = async (storyIds)=>{\n    try {\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.writeBatch)(db);\n        storyIds.forEach((id)=>{\n            const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", id);\n            batch.delete(storyRef);\n        });\n        await batch.commit();\n    } catch (error) {\n        console.error(\"Error batch deleting stories:\", error);\n        throw new Error(\"Failed to batch delete stories\");\n    }\n};\n// Pagination support\nconst getStoriesPaginated = async function(userId) {\n    let pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, lastDoc = arguments.length > 2 ? arguments[2] : void 0;\n    try {\n        let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.limit)(pageSize));\n        if (lastDoc) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.startAfter)(lastDoc));\n        }\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const stories = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        return {\n            stories,\n            lastDoc: querySnapshot.docs[querySnapshot.docs.length - 1] || null\n        };\n    } catch (error) {\n        console.error(\"Error getting paginated stories:\", error);\n        throw new Error(\"Failed to get paginated stories\");\n    }\n};\n// Search stories\nconst searchStories = async (userId, searchTerm)=>{\n    try {\n        const storiesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(storiesQuery);\n        const stories = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Client-side search for better flexibility\n        return stories.filter((story)=>story.title.toLowerCase().includes(searchTerm.toLowerCase()) || story.content.toLowerCase().includes(searchTerm.toLowerCase()) || story.config.focus.toLowerCase().includes(searchTerm.toLowerCase()) || story.config.tone.toLowerCase().includes(searchTerm.toLowerCase()));\n    } catch (error) {\n        console.error(\"Error searching stories:\", error);\n        throw new Error(\"Failed to search stories\");\n    }\n};\n// Story statistics\nconst getStoryStats = async (userId)=>{\n    try {\n        const storiesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(storiesQuery);\n        const stories = querySnapshot.docs.map((doc)=>doc.data());\n        const stats = {\n            total: stories.length,\n            completed: 0,\n            inProgress: 0,\n            failed: 0,\n            byFocus: {},\n            byTone: {}\n        };\n        stories.forEach((story)=>{\n            // Count by status\n            stats[story.status]++;\n            // Count by focus\n            stats.byFocus[story.config.focus] = (stats.byFocus[story.config.focus] || 0) + 1;\n            // Count by tone\n            stats.byTone[story.config.tone] = (stats.byTone[story.config.tone] || 0) + 1;\n        });\n        return stats;\n    } catch (error) {\n        console.error(\"Error getting story stats:\", error);\n        throw new Error(\"Failed to get story statistics\");\n    }\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWVuSSx5REFBS0EsQ0FDeEJILDhEQUFVQSxDQUFDc0MsSUFBSSxZQUNmbEMseURBQUtBLENBQUMsVUFBVSxNQUFNNEU7UUFHeEIsTUFBTVksZ0JBQWdCLE1BQU10RiwyREFBT0EsQ0FBQ2dJO1FBQ3BDLE1BQU1iLFVBQVU3QixjQUFjQyxJQUFJLENBQUNDLEdBQUcsQ0FBQ3ZGLENBQUFBLE1BQU9BLElBQUl5RixJQUFJO1FBRXRELE1BQU0wQyxRQUFRO1lBQ1pDLE9BQU9sQixRQUFRckYsTUFBTTtZQUNyQndHLFdBQVc7WUFDWEMsWUFBWTtZQUNaQyxRQUFRO1lBQ1JDLFNBQVMsQ0FBQztZQUNWQyxRQUFRLENBQUM7UUFDWDtRQUVBdkIsUUFBUUcsT0FBTyxDQUFDbEQsQ0FBQUE7WUFDZCxrQkFBa0I7WUFDbEJnRSxLQUFLLENBQUNoRSxNQUFNRixNQUFNLENBQUM7WUFFbkIsaUJBQWlCO1lBQ2pCa0UsTUFBTUssT0FBTyxDQUFDckUsTUFBTU8sTUFBTSxDQUFDQyxLQUFLLENBQUMsR0FBRyxDQUFDd0QsTUFBTUssT0FBTyxDQUFDckUsTUFBTU8sTUFBTSxDQUFDQyxLQUFLLENBQUMsSUFBSSxLQUFLO1lBRS9FLGdCQUFnQjtZQUNoQndELE1BQU1NLE1BQU0sQ0FBQ3RFLE1BQU1PLE1BQU0sQ0FBQ0UsSUFBSSxDQUFDLEdBQUcsQ0FBQ3VELE1BQU1NLE1BQU0sQ0FBQ3RFLE1BQU1PLE1BQU0sQ0FBQ0UsSUFBSSxDQUFDLElBQUksS0FBSztRQUM3RTtRQUVBLE9BQU91RDtJQUNULEVBQUUsT0FBT2xHLE9BQU87UUFDZHpCLFFBQVF5QixLQUFLLENBQUMsOEJBQThCQTtRQUM1QyxNQUFNLElBQUlRLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZmlyZWJhc2UudHM/MTU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGluaXRpYWxpemVBcHAsIGdldEFwcHMsIGdldEFwcCB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBnZXRBdXRoIH0gZnJvbSAnZmlyZWJhc2UvYXV0aCc7XG5pbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGFkZERvYywgc2VydmVyVGltZXN0YW1wLCBxdWVyeSwgd2hlcmUsIG9yZGVyQnksIGdldERvY3MsIGRvYywgZ2V0RG9jLCB1cGRhdGVEb2MsIHdyaXRlQmF0Y2gsIGRlbGV0ZURvYywgbGltaXQsIHN0YXJ0QWZ0ZXIsIERvY3VtZW50U25hcHNob3QsIG9uU25hcHNob3QgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgZ2V0QW5hbHl0aWNzIH0gZnJvbSAnZmlyZWJhc2UvYW5hbHl0aWNzJztcbmltcG9ydCB7IFRpbWVzdGFtcCB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5cbi8vIExvZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIGRlYnVnZ2luZ1xuY29uc29sZS5sb2coJ0ZpcmViYXNlIENvbmZpZzonLCB7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBhdXRoRG9tYWluOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTiA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgbWVzc2FnaW5nU2VuZGVySWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgYXBwSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBtZWFzdXJlbWVudElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRCA/ICdTZXQnIDogJ05vdCBTZXQnXG59KTtcblxuY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSxcbiAgYXV0aERvbWFpbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4sXG4gIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCxcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQsXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lELFxuICBhcHBJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lELFxuICBtZWFzdXJlbWVudElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRFxufTtcblxuLy8gQWRkIGNvbm5lY3Rpb24gc3RhdHVzIHRyYWNraW5nXG5sZXQgaXNDb25uZWN0ZWQgPSBmYWxzZTtcblxuLy8gSW5pdGlhbGl6ZSBGaXJlYmFzZSB3aXRoIGNvbm5lY3Rpb24gbW9uaXRvcmluZ1xuY29uc3QgYXBwID0gZ2V0QXBwcygpLmxlbmd0aCA/IGdldEFwcCgpIDogaW5pdGlhbGl6ZUFwcChmaXJlYmFzZUNvbmZpZyk7XG5jb25zdCBhdXRoID0gZ2V0QXV0aChhcHApO1xuY29uc3QgZGIgPSBnZXRGaXJlc3RvcmUoYXBwKTtcblxuLy8gTW9uaXRvciBjb25uZWN0aW9uIHN0YXR1cyB1c2luZyBvblNuYXBzaG90XG5jb25zdCBjb25uZWN0aW9uUmVmID0gZG9jKGRiLCAnX2hlYWx0aCcsICdjb25uZWN0aW9uJyk7XG5vblNuYXBzaG90KGNvbm5lY3Rpb25SZWYsIFxuICAoKSA9PiB7XG4gICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKCdGaXJlYmFzZSBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gIH0sXG4gIChlcnJvcikgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZpcmViYXNlIGNvbm5lY3Rpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIH1cbik7XG5cbi8vIENvbm5lY3Rpb24gc3RhdHVzIGNoZWNrIGZ1bmN0aW9uXG5jb25zdCBjaGVja0Nvbm5lY3Rpb24gPSBhc3luYyAoKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gIGlmICghaXNDb25uZWN0ZWQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVHJ5IGEgc2ltcGxlIHJlYWQgb3BlcmF0aW9uIHRvIGNoZWNrIGNvbm5lY3Rpb25cbiAgICAgIGF3YWl0IGdldERvYyhjb25uZWN0aW9uUmVmKTtcbiAgICAgIGlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFJldHJ5IHV0aWxpdHkgZnVuY3Rpb25cbmNvbnN0IHdpdGhSZXRyeSA9IGFzeW5jIDxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBQcm9taXNlPFQ+LFxuICBtYXhSZXRyaWVzOiBudW1iZXIgPSAzLFxuICBkZWxheTogbnVtYmVyID0gMTAwMFxuKTogUHJvbWlzZTxUPiA9PiB7XG4gIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG4gIFxuICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSBtYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgY29ubmVjdGlvbiBiZWZvcmUgZWFjaCBhdHRlbXB0XG4gICAgICBpZiAoIWF3YWl0IGNoZWNrQ29ubmVjdGlvbigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29ubmVjdGlvbiB0byBGaXJlYmFzZScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gYXdhaXQgb3BlcmF0aW9uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgY29uc29sZS53YXJuKGBBdHRlbXB0ICR7YXR0ZW1wdH0gZmFpbGVkOmAsIGVycm9yKTtcbiAgICAgIFxuICAgICAgaWYgKGF0dGVtcHQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgY29uc3QgYmFja29mZkRlbGF5ID0gZGVsYXkgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmRGVsYXkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHRocm93IGxhc3RFcnJvcjtcbn07XG5cbi8vIEVuaGFuY2VkIGVycm9yIGxvZ2dpbmdcbmNvbnN0IGxvZ0Vycm9yID0gKG9wZXJhdGlvbjogc3RyaW5nLCBlcnJvcjogYW55LCBjb250ZXh0PzogYW55KSA9PiB7XG4gIGNvbnN0IGVycm9yRGV0YWlscyA9IHtcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBvcGVyYXRpb24sXG4gICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB7XG4gICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFjayxcbiAgICAgIGNvZGU6ICdjb2RlJyBpbiBlcnJvciA/IChlcnJvciBhcyBhbnkpLmNvZGUgOiB1bmRlZmluZWRcbiAgICB9IDogZXJyb3IsXG4gICAgY29udGV4dCxcbiAgICBjb25uZWN0aW9uU3RhdHVzOiBpc0Nvbm5lY3RlZFxuICB9O1xuICBcbiAgY29uc29sZS5lcnJvcignRmlyZWJhc2UgT3BlcmF0aW9uIEVycm9yOicsIGVycm9yRGV0YWlscyk7XG4gIHJldHVybiBlcnJvckRldGFpbHM7XG59O1xuXG5sZXQgYW5hbHl0aWNzO1xuXG50cnkge1xuICAvLyBJbml0aWFsaXplIEFuYWx5dGljcyBvbmx5IGluIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgYW5hbHl0aWNzID0gZ2V0QW5hbHl0aWNzKGFwcCk7XG4gIH1cbiAgY29uc29sZS5sb2coJ0ZpcmViYXNlIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIEZpcmViYXNlOicsIGVycm9yKTtcbiAgdGhyb3cgZXJyb3I7XG59XG5cbi8vIEluaXRpYWxpemUgY29sbGVjdGlvbnNcbmV4cG9ydCBjb25zdCBzdG9yaWVzQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24oZGIsICdzdG9yaWVzJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcnlDb25maWcge1xuICBpbmR1c3RyeTogc3RyaW5nO1xuICBjb21wYW55U2l6ZTogc3RyaW5nO1xuICByb2xlOiBzdHJpbmc7XG4gIGV4cGVyaWVuY2U6IHN0cmluZztcbiAgZm9jdXM6IHN0cmluZztcbiAgdG9uZTogc3RyaW5nO1xuICBmb3JtYXQ6IHN0cmluZztcbiAgbGVuZ3RoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Rvcnkge1xuICBpZD86IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBjb25maWc6IFN0b3J5Q29uZmlnO1xuICB1c2VySWQ6IHN0cmluZztcbiAgc3RhdHVzOiAnY29tcGxldGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnZmFpbGVkJztcbiAgY3JlYXRlZEF0OiBUaW1lc3RhbXA7XG4gIGVycm9yPzogU3RvcnlHZW5lcmF0aW9uRXJyb3I7XG4gIGdlbmVyYXRpb25BdHRlbXB0cz86IG51bWJlcjtcbiAgbGFzdEF0dGVtcHRBdD86IGFueTtcbiAgc3RvcnlTdHlsZTogc3RyaW5nO1xuICBhY1N0eWxlOiBzdHJpbmc7XG59XG5cbi8vIEN1c3RvbSBlcnJvciB0eXBlcyBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nXG5leHBvcnQgY2xhc3MgRmlyZWJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHB1YmxpYyBjb2RlOiBzdHJpbmcsXG4gICAgcHVibGljIHN0YXR1czogbnVtYmVyID0gNTAwXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdGaXJlYmFzZUVycm9yJztcbiAgfVxufVxuXG4vLyBFbmhhbmNlZCB2YWxpZGF0aW9uIGZ1bmN0aW9uXG5jb25zdCB2YWxpZGF0ZVN0b3J5ID0gKHN0b3J5OiBPbWl0PFN0b3J5LCAnaWQnIHwgJ2NyZWF0ZWRBdCc+KSA9PiB7XG4gIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBSZXF1aXJlZCBmaWVsZHMgdmFsaWRhdGlvblxuICBpZiAoIXN0b3J5LnRpdGxlPy50cmltKCkpIGVycm9ycy5wdXNoKCdUaXRsZSBpcyByZXF1aXJlZCcpO1xuICBpZiAoIXN0b3J5LmNvbnRlbnQ/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0NvbnRlbnQgaXMgcmVxdWlyZWQnKTtcbiAgaWYgKCFzdG9yeS51c2VySWQ/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ1VzZXIgSUQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBDb25maWcgdmFsaWRhdGlvblxuICBpZiAoIXN0b3J5LmNvbmZpZykge1xuICAgIGVycm9ycy5wdXNoKCdDb25maWd1cmF0aW9uIGlzIHJlcXVpcmVkJyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgeyBmb2N1cywgdG9uZSwgZm9ybWF0LCBsZW5ndGggfSA9IHN0b3J5LmNvbmZpZztcbiAgICBpZiAoIWZvY3VzPy50cmltKCkpIGVycm9ycy5wdXNoKCdGb2N1cyBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghdG9uZT8udHJpbSgpKSBlcnJvcnMucHVzaCgnVG9uZSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghZm9ybWF0Py50cmltKCkpIGVycm9ycy5wdXNoKCdGb3JtYXQgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAoIWxlbmd0aD8udHJpbSgpKSBlcnJvcnMucHVzaCgnTGVuZ3RoIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICAvLyBTdGF0dXMgdmFsaWRhdGlvblxuICBpZiAoIXN0b3J5LnN0YXR1cyB8fCAhWydjb21wbGV0ZWQnLCAnaW5fcHJvZ3Jlc3MnLCAnZmFpbGVkJ10uaW5jbHVkZXMoc3Rvcnkuc3RhdHVzKSkge1xuICAgIGVycm9ycy5wdXNoKCdJbnZhbGlkIHN0YXR1cycpO1xuICB9XG5cbiAgLy8gQ29udGVudCBsZW5ndGggdmFsaWRhdGlvblxuICBpZiAoc3RvcnkuY29udGVudC5sZW5ndGggPCA1MCkge1xuICAgIGVycm9ycy5wdXNoKCdDb250ZW50IG11c3QgYmUgYXQgbGVhc3QgNTAgY2hhcmFjdGVycyBsb25nJyk7XG4gIH1cblxuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihlcnJvcnMuam9pbignLCAnKSwgJ0lOVkFMSURfREFUQScsIDQwMCk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIGdldCBzdG9yaWVzIGZvciB0aGUgY3VycmVudCB1c2VyXG5leHBvcnQgY29uc3QgZ2V0U3RvcmllcyA9IGFzeW5jICgpID0+IHtcbiAgcmV0dXJuIHdpdGhSZXRyeShhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgICAgaWYgKCF1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byBmZXRjaCBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHEgPSBxdWVyeShcbiAgICAgICAgc3Rvcmllc0NvbGxlY3Rpb24sXG4gICAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VyLnVpZCksXG4gICAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJylcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgICAgcmV0dXJuIHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+ICh7XG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIC4uLmRvYy5kYXRhKClcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nRXJyb3IoJ2dldFN0b3JpZXMnLCBlcnJvciwgeyB1c2VySWQ6IGF1dGguY3VycmVudFVzZXI/LnVpZCB9KTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICAgJ0ZhaWxlZCB0byBmZXRjaCBzdG9yaWVzLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicsXG4gICAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICAgIDUwMFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gRnVuY3Rpb24gdG8gc2F2ZSBhIHN0b3J5IHRvIEZpcmVzdG9yZVxuZXhwb3J0IGNvbnN0IHNhdmVTdG9yeSA9IGFzeW5jIChzdG9yeTogT21pdDxTdG9yeSwgJ2lkJyB8ICdjcmVhdGVkQXQnPik6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIHJldHVybiB3aXRoUmV0cnkoYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gc2F2ZSBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgICB9XG5cbiAgICAgIHZhbGlkYXRlU3Rvcnkoc3RvcnkpO1xuXG4gICAgICBjb25zdCBzdG9yeURhdGEgPSB7XG4gICAgICAgIC4uLnN0b3J5LFxuICAgICAgICB1c2VySWQ6IHVzZXIudWlkLFxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnIGFzIGNvbnN0LFxuICAgICAgICBnZW5lcmF0aW9uQXR0ZW1wdHM6IDAsXG4gICAgICAgIGxhc3RBdHRlbXB0QXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2Moc3Rvcmllc0NvbGxlY3Rpb24sIHN0b3J5RGF0YSk7XG4gICAgICByZXR1cm4gZG9jUmVmLmlkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dFcnJvcignc2F2ZVN0b3J5JywgZXJyb3IsIHsgXG4gICAgICAgIHVzZXJJZDogYXV0aC5jdXJyZW50VXNlcj8udWlkLFxuICAgICAgICBzdG9yeVRpdGxlOiBzdG9yeS50aXRsZSxcbiAgICAgICAgc3RvcnlDb25maWc6IHN0b3J5LmNvbmZpZ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmICgnY29kZScgaW4gZXJyb3IpIHtcbiAgICAgICAgICBjb25zdCBmaXJlYmFzZUVycm9yID0gZXJyb3IgYXMgeyBjb2RlOiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZyB9O1xuICAgICAgICAgIHN3aXRjaCAoZmlyZWJhc2VFcnJvci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdwZXJtaXNzaW9uLWRlbmllZCc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdQZXJtaXNzaW9uIGRlbmllZC4gUGxlYXNlIGNoZWNrIHlvdXIgYXV0aGVudGljYXRpb24gc3RhdHVzLicsICdQRVJNSVNTSU9OX0RFTklFRCcsIDQwMyk7XG4gICAgICAgICAgICBjYXNlICd1bmF1dGhlbnRpY2F0ZWQnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignUGxlYXNlIHNpZ24gaW4gdG8gc2F2ZSBzdG9yaWVzLicsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgICAgICAgICAgY2FzZSAnaW52YWxpZC1hcmd1bWVudCc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdJbnZhbGlkIHN0b3J5IGRhdGEgcHJvdmlkZWQuJywgJ0lOVkFMSURfREFUQScsIDQwMCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignRmFpbGVkIHRvIHNhdmUgc3RvcnkuIFBsZWFzZSB0cnkgYWdhaW4uJywgJ1NBVkVfRVJST1InLCA1MDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICAgJ0ZhaWxlZCB0byBzYXZlIHN0b3J5LiBQbGVhc2UgdHJ5IGFnYWluLicsXG4gICAgICAgICdTQVZFX0VSUk9SJyxcbiAgICAgICAgNTAwXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBGdW5jdGlvbiB0byB1cGRhdGUgYSBzdG9yeVxuZXhwb3J0IGNvbnN0IHVwZGF0ZVN0b3J5ID0gYXN5bmMgKHN0b3J5SWQ6IHN0cmluZywgdXBkYXRlczogUGFydGlhbDxPbWl0PFN0b3J5LCAnaWQnIHwgJ2NyZWF0ZWRBdCcgfCAndXNlcklkJz4+KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gdXBkYXRlIHN0b3JpZXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGV4aXN0aW5nIHN0b3J5IHRvIHZlcmlmeSBvd25lcnNoaXBcbiAgICBjb25zdCBzdG9yeVJlZiA9IGRvYyhkYiwgJ3N0b3JpZXMnLCBzdG9yeUlkKTtcbiAgICBjb25zdCBzdG9yeVNuYXAgPSBhd2FpdCBnZXREb2Moc3RvcnlSZWYpO1xuXG4gICAgaWYgKCFzdG9yeVNuYXAuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdTdG9yeSBub3QgZm91bmQnLCAnTk9UX0ZPVU5EJywgNDA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yeURhdGEgPSBzdG9yeVNuYXAuZGF0YSgpIGFzIFN0b3J5O1xuICAgIGlmIChzdG9yeURhdGEudXNlcklkICE9PSB1c2VyLnVpZCkge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VuYXV0aG9yaXplZCB0byB1cGRhdGUgdGhpcyBzdG9yeScsICdVTkFVVEhPUklaRUQnLCA0MDMpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRoZSB1cGRhdGVkIGRhdGFcbiAgICBjb25zdCB1cGRhdGVkU3RvcnkgPSB7IC4uLnN0b3J5RGF0YSwgLi4udXBkYXRlcyB9O1xuICAgIHZhbGlkYXRlU3RvcnkodXBkYXRlZFN0b3J5KTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc3RvcnlcbiAgICBhd2FpdCB1cGRhdGVEb2Moc3RvcnlSZWYsIHtcbiAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0b3J5SWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHN0b3J5OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gdXBkYXRlIHN0b3J5JyxcbiAgICAgICdVUERBVEVfRVJST1InLFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IgPyA1MDAgOiA1MDBcbiAgICApO1xuICB9XG59O1xuXG4vLyBGdW5jdGlvbiB0byBnZXQgYSBzaW5nbGUgc3RvcnlcbmV4cG9ydCBjb25zdCBnZXRTdG9yeSA9IGFzeW5jIChzdG9yeUlkOiBzdHJpbmcpOiBQcm9taXNlPFN0b3J5IHwgbnVsbD4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGdldCBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEb2MgPSBhd2FpdCBnZXREb2MoZG9jKGRiLCAnc3RvcmllcycsIHN0b3J5SWQpKTtcbiAgICBpZiAoIXN0b3J5RG9jLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignU3Rvcnkgbm90IGZvdW5kJywgJ05PVF9GT1VORCcsIDQwNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEYXRhID0gc3RvcnlEb2MuZGF0YSgpIGFzIFN0b3J5O1xuICAgIGlmIChzdG9yeURhdGEudXNlcklkICE9PSB1c2VyLnVpZCkge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VuYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBzdG9yeScsICdVTkFVVEhPUklaRUQnLCA0MDMpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpZDogc3RvcnlEb2MuaWQsXG4gICAgICAuLi5zdG9yeURhdGFcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0b3J5OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gZ2V0IHN0b3J5JyxcbiAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEFkZCBuZXcgZXJyb3IgdHlwZXMgZm9yIHN0b3J5IGdlbmVyYXRpb25cbmV4cG9ydCBpbnRlcmZhY2UgU3RvcnlHZW5lcmF0aW9uRXJyb3Ige1xuICBjb2RlOiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgZGV0YWlscz86IGFueTtcbiAgdGltZXN0YW1wOiBEYXRlO1xuICByZXRyeUNvdW50PzogbnVtYmVyO1xufVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgYSBzdG9yeSB3aXRoIGluaXRpYWwgc3RhdHVzIGFuZCBlcnJvciB0cmFja2luZ1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0b3J5V2l0aFN0YXR1cyA9IGFzeW5jIChcbiAgc3Rvcnk6IE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0JyB8ICdzdGF0dXMnPixcbiAgc3RhdHVzOiAnaW5fcHJvZ3Jlc3MnIHwgJ2ZhaWxlZCcgPSAnaW5fcHJvZ3Jlc3MnLFxuICBlcnJvcj86IFN0b3J5R2VuZXJhdGlvbkVycm9yXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byBjcmVhdGUgc3RvcmllcycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBpbml0aWFsIHN0b3J5IGRvY3VtZW50IHdpdGggZXJyb3IgdHJhY2tpbmdcbiAgICBjb25zdCBkb2NSZWYgPSBhd2FpdCBhZGREb2Moc3Rvcmllc0NvbGxlY3Rpb24sIHtcbiAgICAgIC4uLnN0b3J5LFxuICAgICAgdXNlcklkOiB1c2VyLnVpZCxcbiAgICAgIHN0YXR1cyxcbiAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICBlcnJvcjogZXJyb3IgPyB7XG4gICAgICAgIC4uLmVycm9yLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSA6IG51bGwsXG4gICAgICBnZW5lcmF0aW9uQXR0ZW1wdHM6IDAsXG4gICAgICBsYXN0QXR0ZW1wdEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRvY1JlZi5pZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgc3Rvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byBjcmVhdGUgc3RvcnknLFxuICAgICAgJ0NSRUFURV9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdG9yeSBnZW5lcmF0aW9uIHN0YXR1cyB3aXRoIGRldGFpbGVkIGVycm9yIHRyYWNraW5nXG5leHBvcnQgY29uc3QgdXBkYXRlU3RvcnlTdGF0dXMgPSBhc3luYyAoXG4gIHN0b3J5SWQ6IHN0cmluZyxcbiAgc3RhdHVzOiAnY29tcGxldGVkJyB8ICdpbl9wcm9ncmVzcycgfCAnZmFpbGVkJyxcbiAgZXJyb3I/OiBTdG9yeUdlbmVyYXRpb25FcnJvclxuKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gdXBkYXRlIHN0b3J5IHN0YXR1cycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3J5UmVmID0gZG9jKGRiLCAnc3RvcmllcycsIHN0b3J5SWQpO1xuICAgIGNvbnN0IHN0b3J5U25hcCA9IGF3YWl0IGdldERvYyhzdG9yeVJlZik7XG5cbiAgICBpZiAoIXN0b3J5U25hcC5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1N0b3J5IG5vdCBmb3VuZCcsICdOT1RfRk9VTkQnLCA0MDQpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3J5RGF0YSA9IHN0b3J5U25hcC5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIHVwZGF0ZSB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlczogYW55ID0ge1xuICAgICAgc3RhdHVzLFxuICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGxhc3RBdHRlbXB0QXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgfTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdXBkYXRlcy5lcnJvciA9IHtcbiAgICAgICAgLi4uZXJyb3IsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuICAgICAgdXBkYXRlcy5nZW5lcmF0aW9uQXR0ZW1wdHMgPSAoc3RvcnlEYXRhLmdlbmVyYXRpb25BdHRlbXB0cyB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgYXdhaXQgdXBkYXRlRG9jKHN0b3J5UmVmLCB1cGRhdGVzKTtcbiAgICByZXR1cm4gc3RvcnlJZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgc3Rvcnkgc3RhdHVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gdXBkYXRlIHN0b3J5IHN0YXR1cycsXG4gICAgICAnVVBEQVRFX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gZ2V0IHN0b3J5IGdlbmVyYXRpb24gc3RhdHVzXG5leHBvcnQgY29uc3QgZ2V0U3RvcnlHZW5lcmF0aW9uU3RhdHVzID0gYXN5bmMgKHN0b3J5SWQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGdldCBzdG9yeSBzdGF0dXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBkb2NSZWYgPSBkb2MoZGIsICdzdG9yaWVzJywgc3RvcnlJZCk7XG4gICAgY29uc3QgZG9jU25hcCA9IGF3YWl0IGdldERvYyhkb2NSZWYpO1xuXG4gICAgaWYgKCFkb2NTbmFwLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignU3Rvcnkgbm90IGZvdW5kJywgJ05PVF9GT1VORCcsIDQwNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEYXRhID0gZG9jU25hcC5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogc3RvcnlEYXRhLnN0YXR1cyxcbiAgICAgIGVycm9yOiBzdG9yeURhdGEuZXJyb3IsXG4gICAgICBnZW5lcmF0aW9uQXR0ZW1wdHM6IHN0b3J5RGF0YS5nZW5lcmF0aW9uQXR0ZW1wdHMgfHwgMCxcbiAgICAgIGxhc3RBdHRlbXB0QXQ6IHN0b3J5RGF0YS5sYXN0QXR0ZW1wdEF0XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzdG9yeSBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byBnZXQgc3Rvcnkgc3RhdHVzJyxcbiAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEJhdGNoIG9wZXJhdGlvbnNcbmV4cG9ydCBjb25zdCBiYXRjaFNhdmVTdG9yaWVzID0gYXN5bmMgKHN0b3JpZXM6IE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0Jz5bXSk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBiYXRjaCA9IHdyaXRlQmF0Y2goZGIpO1xuICAgIGNvbnN0IHN0b3J5SWRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgc3Rvcmllcy5mb3JFYWNoKHN0b3J5ID0+IHtcbiAgICAgIHZhbGlkYXRlU3Rvcnkoc3RvcnkpO1xuICAgICAgY29uc3Qgc3RvcnlSZWYgPSBkb2MoY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKSk7XG4gICAgICBiYXRjaC5zZXQoc3RvcnlSZWYsIHtcbiAgICAgICAgLi4uc3RvcnksXG4gICAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCcgYXMgY29uc3RcbiAgICAgIH0pO1xuICAgICAgc3RvcnlJZHMucHVzaChzdG9yeVJlZi5pZCk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBiYXRjaC5jb21taXQoKTtcbiAgICByZXR1cm4gc3RvcnlJZHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYmF0Y2ggc2F2aW5nIHN0b3JpZXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGJhdGNoIHNhdmUgc3RvcmllcycpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYmF0Y2hEZWxldGVTdG9yaWVzID0gYXN5bmMgKHN0b3J5SWRzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhdGNoID0gd3JpdGVCYXRjaChkYik7XG4gICAgXG4gICAgc3RvcnlJZHMuZm9yRWFjaChpZCA9PiB7XG4gICAgICBjb25zdCBzdG9yeVJlZiA9IGRvYyhkYiwgJ3N0b3JpZXMnLCBpZCk7XG4gICAgICBiYXRjaC5kZWxldGUoc3RvcnlSZWYpO1xuICAgIH0pO1xuXG4gICAgYXdhaXQgYmF0Y2guY29tbWl0KCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYmF0Y2ggZGVsZXRpbmcgc3RvcmllczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYmF0Y2ggZGVsZXRlIHN0b3JpZXMnKTtcbiAgfVxufTtcblxuLy8gUGFnaW5hdGlvbiBzdXBwb3J0XG5leHBvcnQgY29uc3QgZ2V0U3Rvcmllc1BhZ2luYXRlZCA9IGFzeW5jIChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHBhZ2VTaXplOiBudW1iZXIgPSAxMCxcbiAgbGFzdERvYz86IERvY3VtZW50U25hcHNob3Rcbik6IFByb21pc2U8eyBzdG9yaWVzOiBTdG9yeVtdOyBsYXN0RG9jOiBEb2N1bWVudFNuYXBzaG90IHwgbnVsbCB9PiA9PiB7XG4gIHRyeSB7XG4gICAgbGV0IHEgPSBxdWVyeShcbiAgICAgIGNvbGxlY3Rpb24oZGIsICdzdG9yaWVzJyksXG4gICAgICB3aGVyZSgndXNlcklkJywgJz09JywgdXNlcklkKSxcbiAgICAgIG9yZGVyQnkoJ2NyZWF0ZWRBdCcsICdkZXNjJyksXG4gICAgICBsaW1pdChwYWdlU2l6ZSlcbiAgICApO1xuXG4gICAgaWYgKGxhc3REb2MpIHtcbiAgICAgIHEgPSBxdWVyeShxLCBzdGFydEFmdGVyKGxhc3REb2MpKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhxKTtcbiAgICBjb25zdCBzdG9yaWVzID0gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAuLi5kb2MuZGF0YSgpXG4gICAgfSBhcyBTdG9yeSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JpZXMsXG4gICAgICBsYXN0RG9jOiBxdWVyeVNuYXBzaG90LmRvY3NbcXVlcnlTbmFwc2hvdC5kb2NzLmxlbmd0aCAtIDFdIHx8IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgcGFnaW5hdGVkIHN0b3JpZXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBwYWdpbmF0ZWQgc3RvcmllcycpO1xuICB9XG59O1xuXG4vLyBTZWFyY2ggc3Rvcmllc1xuZXhwb3J0IGNvbnN0IHNlYXJjaFN0b3JpZXMgPSBhc3luYyAoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBzZWFyY2hUZXJtOiBzdHJpbmdcbik6IFByb21pc2U8U3RvcnlbXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0b3JpZXNRdWVyeSA9IHF1ZXJ5KFxuICAgICAgY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKSxcbiAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxuICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKVxuICAgICk7XG4gICAgXG4gICAgY29uc3QgcXVlcnlTbmFwc2hvdCA9IGF3YWl0IGdldERvY3Moc3Rvcmllc1F1ZXJ5KTtcbiAgICBjb25zdCBzdG9yaWVzID0gcXVlcnlTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gKHtcbiAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAuLi5kb2MuZGF0YSgpXG4gICAgfSBhcyBTdG9yeSkpO1xuXG4gICAgLy8gQ2xpZW50LXNpZGUgc2VhcmNoIGZvciBiZXR0ZXIgZmxleGliaWxpdHlcbiAgICByZXR1cm4gc3Rvcmllcy5maWx0ZXIoc3RvcnkgPT4gXG4gICAgICBzdG9yeS50aXRsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgIHN0b3J5LmNvbnRlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBzdG9yeS5jb25maWcuZm9jdXMudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtLnRvTG93ZXJDYXNlKCkpIHx8XG4gICAgICBzdG9yeS5jb25maWcudG9uZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSlcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlYXJjaGluZyBzdG9yaWVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggc3RvcmllcycpO1xuICB9XG59O1xuXG4vLyBTdG9yeSBzdGF0aXN0aWNzXG5leHBvcnQgY29uc3QgZ2V0U3RvcnlTdGF0cyA9IGFzeW5jICh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8e1xuICB0b3RhbDogbnVtYmVyO1xuICBjb21wbGV0ZWQ6IG51bWJlcjtcbiAgaW5Qcm9ncmVzczogbnVtYmVyO1xuICBmYWlsZWQ6IG51bWJlcjtcbiAgYnlGb2N1czogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgYnlUb25lOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xufT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0b3JpZXNRdWVyeSA9IHF1ZXJ5KFxuICAgICAgY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKSxcbiAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhzdG9yaWVzUXVlcnkpO1xuICAgIGNvbnN0IHN0b3JpZXMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiBkb2MuZGF0YSgpIGFzIFN0b3J5KTtcblxuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgdG90YWw6IHN0b3JpZXMubGVuZ3RoLFxuICAgICAgY29tcGxldGVkOiAwLFxuICAgICAgaW5Qcm9ncmVzczogMCxcbiAgICAgIGZhaWxlZDogMCxcbiAgICAgIGJ5Rm9jdXM6IHt9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgICBieVRvbmU6IHt9IGFzIFJlY29yZDxzdHJpbmcsIG51bWJlcj5cbiAgICB9O1xuXG4gICAgc3Rvcmllcy5mb3JFYWNoKHN0b3J5ID0+IHtcbiAgICAgIC8vIENvdW50IGJ5IHN0YXR1c1xuICAgICAgc3RhdHNbc3Rvcnkuc3RhdHVzXSsrO1xuICAgICAgXG4gICAgICAvLyBDb3VudCBieSBmb2N1c1xuICAgICAgc3RhdHMuYnlGb2N1c1tzdG9yeS5jb25maWcuZm9jdXNdID0gKHN0YXRzLmJ5Rm9jdXNbc3RvcnkuY29uZmlnLmZvY3VzXSB8fCAwKSArIDE7XG4gICAgICBcbiAgICAgIC8vIENvdW50IGJ5IHRvbmVcbiAgICAgIHN0YXRzLmJ5VG9uZVtzdG9yeS5jb25maWcudG9uZV0gPSAoc3RhdHMuYnlUb25lW3N0b3J5LmNvbmZpZy50b25lXSB8fCAwKSArIDE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RhdHM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBzdG9yeSBzdGF0czonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHN0b3J5IHN0YXRpc3RpY3MnKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgYXBwLCBhdXRoLCBkYiwgYW5hbHl0aWNzIH07ICJdLCJuYW1lcyI6WyJpbml0aWFsaXplQXBwIiwiZ2V0QXBwcyIsImdldEFwcCIsImdldEF1dGgiLCJnZXRGaXJlc3RvcmUiLCJjb2xsZWN0aW9uIiwiYWRkRG9jIiwic2VydmVyVGltZXN0YW1wIiwicXVlcnkiLCJ3aGVyZSIsIm9yZGVyQnkiLCJnZXREb2NzIiwiZG9jIiwiZ2V0RG9jIiwidXBkYXRlRG9jIiwid3JpdGVCYXRjaCIsImxpbWl0Iiwic3RhcnRBZnRlciIsIm9uU25hcHNob3QiLCJnZXRBbmFseXRpY3MiLCJjb25zb2xlIiwibG9nIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVkiLCJhdXRoRG9tYWluIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4iLCJwcm9qZWN0SWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEIiwic3RvcmFnZUJ1Y2tldCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1NUT1JBR0VfQlVDS0VUIiwibWVzc2FnaW5nU2VuZGVySWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lEIiwiYXBwSWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUFBfSUQiLCJtZWFzdXJlbWVudElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVBU1VSRU1FTlRfSUQiLCJmaXJlYmFzZUNvbmZpZyIsImlzQ29ubmVjdGVkIiwiYXBwIiwibGVuZ3RoIiwiYXV0aCIsImRiIiwiY29ubmVjdGlvblJlZiIsImVycm9yIiwiY2hlY2tDb25uZWN0aW9uIiwid2l0aFJldHJ5Iiwib3BlcmF0aW9uIiwibWF4UmV0cmllcyIsImRlbGF5IiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsIkVycm9yIiwid2FybiIsImJhY2tvZmZEZWxheSIsIk1hdGgiLCJwb3ciLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJsb2dFcnJvciIsImNvbnRleHQiLCJlcnJvckRldGFpbHMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJuYW1lIiwibWVzc2FnZSIsInN0YWNrIiwiY29kZSIsInVuZGVmaW5lZCIsImNvbm5lY3Rpb25TdGF0dXMiLCJhbmFseXRpY3MiLCJzdG9yaWVzQ29sbGVjdGlvbiIsIkZpcmViYXNlRXJyb3IiLCJjb25zdHJ1Y3RvciIsInN0YXR1cyIsInZhbGlkYXRlU3RvcnkiLCJzdG9yeSIsImVycm9ycyIsInRpdGxlIiwidHJpbSIsInB1c2giLCJjb250ZW50IiwidXNlcklkIiwiY29uZmlnIiwiZm9jdXMiLCJ0b25lIiwiZm9ybWF0IiwiaW5jbHVkZXMiLCJqb2luIiwiZ2V0U3RvcmllcyIsInVzZXIiLCJjdXJyZW50VXNlciIsInEiLCJ1aWQiLCJxdWVyeVNuYXBzaG90IiwiZG9jcyIsIm1hcCIsImlkIiwiZGF0YSIsInNhdmVTdG9yeSIsInN0b3J5RGF0YSIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsImdlbmVyYXRpb25BdHRlbXB0cyIsImxhc3RBdHRlbXB0QXQiLCJkb2NSZWYiLCJzdG9yeVRpdGxlIiwic3RvcnlDb25maWciLCJmaXJlYmFzZUVycm9yIiwidXBkYXRlU3RvcnkiLCJzdG9yeUlkIiwidXBkYXRlcyIsInN0b3J5UmVmIiwic3RvcnlTbmFwIiwiZXhpc3RzIiwidXBkYXRlZFN0b3J5IiwiZ2V0U3RvcnkiLCJzdG9yeURvYyIsImNyZWF0ZVN0b3J5V2l0aFN0YXR1cyIsInVwZGF0ZVN0b3J5U3RhdHVzIiwiZ2V0U3RvcnlHZW5lcmF0aW9uU3RhdHVzIiwiZG9jU25hcCIsImJhdGNoU2F2ZVN0b3JpZXMiLCJzdG9yaWVzIiwiYmF0Y2giLCJzdG9yeUlkcyIsImZvckVhY2giLCJzZXQiLCJjb21taXQiLCJiYXRjaERlbGV0ZVN0b3JpZXMiLCJkZWxldGUiLCJnZXRTdG9yaWVzUGFnaW5hdGVkIiwicGFnZVNpemUiLCJsYXN0RG9jIiwic2VhcmNoU3RvcmllcyIsInNlYXJjaFRlcm0iLCJzdG9yaWVzUXVlcnkiLCJmaWx0ZXIiLCJ0b0xvd2VyQ2FzZSIsImdldFN0b3J5U3RhdHMiLCJzdGF0cyIsInRvdGFsIiwiY29tcGxldGVkIiwiaW5Qcm9ncmVzcyIsImZhaWxlZCIsImJ5Rm9jdXMiLCJieVRvbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firebase.ts\n"));

/***/ })

});