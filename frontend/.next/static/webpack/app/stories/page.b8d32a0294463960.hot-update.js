"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/stories/page",{

/***/ "(app-pages-browser)/./src/lib/firebase.ts":
/*!*****************************!*\
  !*** ./src/lib/firebase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FirebaseError: function() { return /* binding */ FirebaseError; },\n/* harmony export */   analytics: function() { return /* binding */ analytics; },\n/* harmony export */   app: function() { return /* binding */ app; },\n/* harmony export */   auth: function() { return /* binding */ auth; },\n/* harmony export */   batchDeleteStories: function() { return /* binding */ batchDeleteStories; },\n/* harmony export */   batchSaveStories: function() { return /* binding */ batchSaveStories; },\n/* harmony export */   createStoryWithStatus: function() { return /* binding */ createStoryWithStatus; },\n/* harmony export */   db: function() { return /* binding */ db; },\n/* harmony export */   getStories: function() { return /* binding */ getStories; },\n/* harmony export */   getStoriesPaginated: function() { return /* binding */ getStoriesPaginated; },\n/* harmony export */   getStory: function() { return /* binding */ getStory; },\n/* harmony export */   getStoryGenerationStatus: function() { return /* binding */ getStoryGenerationStatus; },\n/* harmony export */   getStoryStats: function() { return /* binding */ getStoryStats; },\n/* harmony export */   saveStory: function() { return /* binding */ saveStory; },\n/* harmony export */   searchStories: function() { return /* binding */ searchStories; },\n/* harmony export */   storiesCollection: function() { return /* binding */ storiesCollection; },\n/* harmony export */   updateStory: function() { return /* binding */ updateStory; },\n/* harmony export */   updateStoryStatus: function() { return /* binding */ updateStoryStatus; }\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/firestore */ \"(app-pages-browser)/./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_analytics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! firebase/analytics */ \"(app-pages-browser)/./node_modules/firebase/analytics/dist/esm/index.esm.js\");\n/* __next_internal_client_entry_do_not_use__ storiesCollection,FirebaseError,getStories,saveStory,updateStory,getStory,createStoryWithStatus,updateStoryStatus,getStoryGenerationStatus,batchSaveStories,batchDeleteStories,getStoriesPaginated,searchStories,getStoryStats,app,auth,db,analytics auto */ \n\n\n\n// Log environment variables for debugging\nconsole.log(\"Firebase Config:\", {\n    apiKey:  true ? \"Set\" : 0,\n    authDomain:  true ? \"Set\" : 0,\n    projectId:  true ? \"Set\" : 0,\n    storageBucket:  true ? \"Set\" : 0,\n    messagingSenderId:  true ? \"Set\" : 0,\n    appId:  true ? \"Set\" : 0,\n    measurementId:  true ? \"Set\" : 0\n});\nconst firebaseConfig = {\n    apiKey: \"AIzaSyAPjxc_Y70cfxyME-ao3WspK8PCeJaTR7k\",\n    authDomain: \"montajai.firebaseapp.com\",\n    projectId: \"montajai\",\n    storageBucket: \"montajai.firebasestorage.app\",\n    messagingSenderId: \"1074834137884\",\n    appId: \"1:1074834137884:web:acaa300a37b9dadc3e10d9\",\n    measurementId: \"G-HSZ6LZR8Q9\"\n};\n// Initialize Firebase\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)() : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig);\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getFirestore)(app);\nlet analytics;\ntry {\n    // Initialize Analytics only in browser environment\n    if (true) {\n        analytics = (0,firebase_analytics__WEBPACK_IMPORTED_MODULE_3__.getAnalytics)(app);\n    }\n    console.log(\"Firebase initialized successfully\");\n} catch (error) {\n    console.error(\"Error initializing Firebase:\", error);\n    throw error;\n}\n// Add security rules for stories collection\nconst storiesCollection = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\");\n// Custom error types for better error handling\nclass FirebaseError extends Error {\n    constructor(message, code, status = 500){\n        super(message);\n        this.code = code;\n        this.status = status;\n        this.name = \"FirebaseError\";\n    }\n}\n// Enhanced validation function\nconst validateStory = (story)=>{\n    var _story_title, _story_content, _story_userId;\n    const errors = [];\n    // Required fields validation\n    if (!((_story_title = story.title) === null || _story_title === void 0 ? void 0 : _story_title.trim())) errors.push(\"Title is required\");\n    if (!((_story_content = story.content) === null || _story_content === void 0 ? void 0 : _story_content.trim())) errors.push(\"Content is required\");\n    if (!((_story_userId = story.userId) === null || _story_userId === void 0 ? void 0 : _story_userId.trim())) errors.push(\"User ID is required\");\n    // Config validation\n    if (!story.config) {\n        errors.push(\"Configuration is required\");\n    } else {\n        const { focus, tone, format, length } = story.config;\n        if (!(focus === null || focus === void 0 ? void 0 : focus.trim())) errors.push(\"Focus is required\");\n        if (!(tone === null || tone === void 0 ? void 0 : tone.trim())) errors.push(\"Tone is required\");\n        if (!(format === null || format === void 0 ? void 0 : format.trim())) errors.push(\"Format is required\");\n        if (!(length === null || length === void 0 ? void 0 : length.trim())) errors.push(\"Length is required\");\n    }\n    // Status validation\n    if (!story.status || ![\n        \"completed\",\n        \"in_progress\",\n        \"failed\"\n    ].includes(story.status)) {\n        errors.push(\"Invalid status\");\n    }\n    // Content length validation\n    if (story.content.length < 50) {\n        errors.push(\"Content must be at least 50 characters long\");\n    }\n    if (errors.length > 0) {\n        throw new FirebaseError(errors.join(\", \"), \"INVALID_DATA\", 400);\n    }\n};\n// Function to get stories for the current user\nconst getStories = async ()=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to fetch stories\", \"UNAUTHENTICATED\", 401);\n        }\n        const q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(storiesCollection, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", user.uid), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        return querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error fetching stories:\", error);\n        throw new FirebaseError(\"Failed to fetch stories\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to save a story to Firestore\nconst saveStory = async (story)=>{\n    try {\n        // Ensure user is authenticated\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to save stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Validate story data\n        validateStory(story);\n        // Create story data with required fields\n        const storyData = {\n            ...story,\n            userId: user.uid,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            status: \"completed\",\n            generationAttempts: 0,\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        };\n        // Add to stories collection\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), storyData);\n        return docRef.id;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        // Handle Firebase specific errors\n        if (error instanceof Error && \"code\" in error) {\n            const firebaseError = error;\n            if (firebaseError.code === \"permission-denied\") {\n                throw new FirebaseError(\"Permission denied. Please check your authentication status.\", \"PERMISSION_DENIED\", 403);\n            }\n        }\n        console.error(\"Error saving story:\", error);\n        throw new FirebaseError(\"Failed to save story\", \"SAVE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to update a story\nconst updateStory = async (storyId, updates)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Get the existing story to verify ownership\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        // Validate the updated data\n        const updatedStory = {\n            ...storyData,\n            ...updates\n        };\n        validateStory(updatedStory);\n        // Update the story\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, {\n            ...updates,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story:\", error);\n        throw new FirebaseError(\"Failed to update story\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get a single story\nconst getStory = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get stories\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyDoc = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId));\n        if (!storyDoc.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storyDoc.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            id: storyDoc.id,\n            ...storyData\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story:\", error);\n        throw new FirebaseError(\"Failed to get story\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to create a story with initial status and error tracking\nconst createStoryWithStatus = async function(story) {\n    let status = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"in_progress\", error = arguments.length > 2 ? arguments[2] : void 0;\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to create stories\", \"UNAUTHENTICATED\", 401);\n        }\n        // Create initial story document with error tracking\n        const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.addDoc)(storiesCollection, {\n            ...story,\n            userId: user.uid,\n            status,\n            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            error: error ? {\n                ...error,\n                timestamp: new Date().toISOString()\n            } : null,\n            generationAttempts: 0,\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        });\n        return docRef.id;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error creating story:\", error);\n        throw new FirebaseError(\"Failed to create story\", \"CREATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to update story generation status with detailed error tracking\nconst updateStoryStatus = async (storyId, status, error)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to update story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const storySnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(storyRef);\n        if (!storySnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = storySnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to update this story\", \"UNAUTHORIZED\", 403);\n        }\n        const updates = {\n            status,\n            updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n            lastAttemptAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)()\n        };\n        if (error) {\n            updates.error = {\n                ...error,\n                timestamp: new Date().toISOString()\n            };\n            updates.generationAttempts = (storyData.generationAttempts || 0) + 1;\n        }\n        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.updateDoc)(storyRef, updates);\n        return storyId;\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error updating story status:\", error);\n        throw new FirebaseError(\"Failed to update story status\", \"UPDATE_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Function to get story generation status\nconst getStoryGenerationStatus = async (storyId)=>{\n    try {\n        const user = auth.currentUser;\n        if (!user) {\n            throw new FirebaseError(\"User must be authenticated to get story status\", \"UNAUTHENTICATED\", 401);\n        }\n        const docRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", storyId);\n        const docSnap = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDoc)(docRef);\n        if (!docSnap.exists()) {\n            throw new FirebaseError(\"Story not found\", \"NOT_FOUND\", 404);\n        }\n        const storyData = docSnap.data();\n        if (storyData.userId !== user.uid) {\n            throw new FirebaseError(\"Unauthorized to access this story\", \"UNAUTHORIZED\", 403);\n        }\n        return {\n            status: storyData.status,\n            error: storyData.error,\n            generationAttempts: storyData.generationAttempts || 0,\n            lastAttemptAt: storyData.lastAttemptAt\n        };\n    } catch (error) {\n        if (error instanceof FirebaseError) {\n            throw error;\n        }\n        console.error(\"Error getting story status:\", error);\n        throw new FirebaseError(\"Failed to get story status\", \"FETCH_ERROR\", error instanceof Error && \"code\" in error ? 500 : 500);\n    }\n};\n// Batch operations\nconst batchSaveStories = async (stories)=>{\n    try {\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.writeBatch)(db);\n        const storyIds = [];\n        stories.forEach((story)=>{\n            validateStory(story);\n            const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"));\n            batch.set(storyRef, {\n                ...story,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.serverTimestamp)(),\n                status: \"completed\"\n            });\n            storyIds.push(storyRef.id);\n        });\n        await batch.commit();\n        return storyIds;\n    } catch (error) {\n        console.error(\"Error batch saving stories:\", error);\n        throw new Error(\"Failed to batch save stories\");\n    }\n};\nconst batchDeleteStories = async (storyIds)=>{\n    try {\n        const batch = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.writeBatch)(db);\n        storyIds.forEach((id)=>{\n            const storyRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.doc)(db, \"stories\", id);\n            batch.delete(storyRef);\n        });\n        await batch.commit();\n    } catch (error) {\n        console.error(\"Error batch deleting stories:\", error);\n        throw new Error(\"Failed to batch delete stories\");\n    }\n};\n// Pagination support\nconst getStoriesPaginated = async function(userId) {\n    let pageSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, lastDoc = arguments.length > 2 ? arguments[2] : void 0;\n    try {\n        let q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.limit)(pageSize));\n        if (lastDoc) {\n            q = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)(q, (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.startAfter)(lastDoc));\n        }\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(q);\n        const stories = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        return {\n            stories,\n            lastDoc: querySnapshot.docs[querySnapshot.docs.length - 1] || null\n        };\n    } catch (error) {\n        console.error(\"Error getting paginated stories:\", error);\n        throw new Error(\"Failed to get paginated stories\");\n    }\n};\n// Search stories\nconst searchStories = async (userId, searchTerm)=>{\n    try {\n        const storiesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.orderBy)(\"createdAt\", \"desc\"));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(storiesQuery);\n        const stories = querySnapshot.docs.map((doc)=>({\n                id: doc.id,\n                ...doc.data()\n            }));\n        // Client-side search for better flexibility\n        return stories.filter((story)=>story.title.toLowerCase().includes(searchTerm.toLowerCase()) || story.content.toLowerCase().includes(searchTerm.toLowerCase()) || story.config.focus.toLowerCase().includes(searchTerm.toLowerCase()) || story.config.tone.toLowerCase().includes(searchTerm.toLowerCase()));\n    } catch (error) {\n        console.error(\"Error searching stories:\", error);\n        throw new Error(\"Failed to search stories\");\n    }\n};\n// Story statistics\nconst getStoryStats = async (userId)=>{\n    try {\n        const storiesQuery = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.query)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.collection)(db, \"stories\"), (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.where)(\"userId\", \"==\", userId));\n        const querySnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_2__.getDocs)(storiesQuery);\n        const stories = querySnapshot.docs.map((doc)=>doc.data());\n        const stats = {\n            total: stories.length,\n            completed: 0,\n            inProgress: 0,\n            failed: 0,\n            byFocus: {},\n            byTone: {}\n        };\n        stories.forEach((story)=>{\n            // Count by status\n            stats[story.status]++;\n            // Count by focus\n            stats.byFocus[story.config.focus] = (stats.byFocus[story.config.focus] || 0) + 1;\n            // Count by tone\n            stats.byTone[story.config.tone] = (stats.byTone[story.config.tone] || 0) + 1;\n        });\n        return stats;\n    } catch (error) {\n        console.error(\"Error getting story stats:\", error);\n        throw new Error(\"Failed to get story statistics\");\n    }\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU1PLE1BQU0sQ0FBQ0UsSUFBSSxDQUFDLElBQUksS0FBSztRQUM3RTtRQUVBLE9BQU93RDtJQUNULEVBQUUsT0FBTzNFLE9BQU87UUFDZHhCLFFBQVF3QixLQUFLLENBQUMsOEJBQThCQTtRQUM1QyxNQUFNLElBQUlHLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZmlyZWJhc2UudHM/MTU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IGluaXRpYWxpemVBcHAsIGdldEFwcHMsIGdldEFwcCB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBnZXRBdXRoIH0gZnJvbSAnZmlyZWJhc2UvYXV0aCc7XG5pbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGFkZERvYywgc2VydmVyVGltZXN0YW1wLCBxdWVyeSwgd2hlcmUsIG9yZGVyQnksIGdldERvY3MsIGRvYywgZ2V0RG9jLCB1cGRhdGVEb2MsIHdyaXRlQmF0Y2gsIGRlbGV0ZURvYywgbGltaXQsIHN0YXJ0QWZ0ZXIsIERvY3VtZW50U25hcHNob3QgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xuaW1wb3J0IHsgZ2V0QW5hbHl0aWNzIH0gZnJvbSAnZmlyZWJhc2UvYW5hbHl0aWNzJztcbmltcG9ydCB7IFRpbWVzdGFtcCB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XG5cbi8vIExvZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIGRlYnVnZ2luZ1xuY29uc29sZS5sb2coJ0ZpcmViYXNlIENvbmZpZzonLCB7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBhdXRoRG9tYWluOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTiA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBwcm9qZWN0SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgbWVzc2FnaW5nU2VuZGVySWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQgPyAnU2V0JyA6ICdOb3QgU2V0JyxcbiAgYXBwSWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCA/ICdTZXQnIDogJ05vdCBTZXQnLFxuICBtZWFzdXJlbWVudElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRCA/ICdTZXQnIDogJ05vdCBTZXQnXG59KTtcblxuY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSxcbiAgYXV0aERvbWFpbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVVUSF9ET01BSU4sXG4gIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCxcbiAgc3RvcmFnZUJ1Y2tldDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQsXG4gIG1lc3NhZ2luZ1NlbmRlcklkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRVNTQUdJTkdfU0VOREVSX0lELFxuICBhcHBJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lELFxuICBtZWFzdXJlbWVudElkOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRFxufTtcblxuLy8gSW5pdGlhbGl6ZSBGaXJlYmFzZVxuY29uc3QgYXBwID0gZ2V0QXBwcygpLmxlbmd0aCA/IGdldEFwcCgpIDogaW5pdGlhbGl6ZUFwcChmaXJlYmFzZUNvbmZpZyk7XG5jb25zdCBhdXRoID0gZ2V0QXV0aChhcHApO1xuY29uc3QgZGIgPSBnZXRGaXJlc3RvcmUoYXBwKTtcblxubGV0IGFuYWx5dGljcztcblxudHJ5IHtcbiAgLy8gSW5pdGlhbGl6ZSBBbmFseXRpY3Mgb25seSBpbiBicm93c2VyIGVudmlyb25tZW50XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGFuYWx5dGljcyA9IGdldEFuYWx5dGljcyhhcHApO1xuICB9XG4gIGNvbnNvbGUubG9nKCdGaXJlYmFzZSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBGaXJlYmFzZTonLCBlcnJvcik7XG4gIHRocm93IGVycm9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0b3J5Q29uZmlnIHtcbiAgaW5kdXN0cnk6IHN0cmluZztcbiAgY29tcGFueVNpemU6IHN0cmluZztcbiAgcm9sZTogc3RyaW5nO1xuICBleHBlcmllbmNlOiBzdHJpbmc7XG4gIGZvY3VzOiBzdHJpbmc7XG4gIHRvbmU6IHN0cmluZztcbiAgZm9ybWF0OiBzdHJpbmc7XG4gIGxlbmd0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0b3J5IHtcbiAgaWQ/OiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgY29uZmlnOiBTdG9yeUNvbmZpZztcbiAgdXNlcklkOiBzdHJpbmc7XG4gIHN0YXR1czogJ2NvbXBsZXRlZCcgfCAnaW5fcHJvZ3Jlc3MnIHwgJ2ZhaWxlZCc7XG4gIGNyZWF0ZWRBdDogVGltZXN0YW1wO1xuICBlcnJvcj86IFN0b3J5R2VuZXJhdGlvbkVycm9yO1xuICBnZW5lcmF0aW9uQXR0ZW1wdHM/OiBudW1iZXI7XG4gIGxhc3RBdHRlbXB0QXQ/OiBhbnk7XG4gIHN0b3J5U3R5bGU6IHN0cmluZztcbiAgYWNTdHlsZTogc3RyaW5nO1xufVxuXG4vLyBBZGQgc2VjdXJpdHkgcnVsZXMgZm9yIHN0b3JpZXMgY29sbGVjdGlvblxuZXhwb3J0IGNvbnN0IHN0b3JpZXNDb2xsZWN0aW9uID0gY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKTtcblxuLy8gQ3VzdG9tIGVycm9yIHR5cGVzIGZvciBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcbmV4cG9ydCBjbGFzcyBGaXJlYmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIGNvZGU6IHN0cmluZyxcbiAgICBwdWJsaWMgc3RhdHVzOiBudW1iZXIgPSA1MDBcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0ZpcmViYXNlRXJyb3InO1xuICB9XG59XG5cbi8vIEVuaGFuY2VkIHZhbGlkYXRpb24gZnVuY3Rpb25cbmNvbnN0IHZhbGlkYXRlU3RvcnkgPSAoc3Rvcnk6IE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0Jz4pID0+IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8vIFJlcXVpcmVkIGZpZWxkcyB2YWxpZGF0aW9uXG4gIGlmICghc3RvcnkudGl0bGU/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ1RpdGxlIGlzIHJlcXVpcmVkJyk7XG4gIGlmICghc3RvcnkuY29udGVudD8udHJpbSgpKSBlcnJvcnMucHVzaCgnQ29udGVudCBpcyByZXF1aXJlZCcpO1xuICBpZiAoIXN0b3J5LnVzZXJJZD8udHJpbSgpKSBlcnJvcnMucHVzaCgnVXNlciBJRCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIENvbmZpZyB2YWxpZGF0aW9uXG4gIGlmICghc3RvcnkuY29uZmlnKSB7XG4gICAgZXJyb3JzLnB1c2goJ0NvbmZpZ3VyYXRpb24gaXMgcmVxdWlyZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IGZvY3VzLCB0b25lLCBmb3JtYXQsIGxlbmd0aCB9ID0gc3RvcnkuY29uZmlnO1xuICAgIGlmICghZm9jdXM/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0ZvY3VzIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCF0b25lPy50cmltKCkpIGVycm9ycy5wdXNoKCdUb25lIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKCFmb3JtYXQ/LnRyaW0oKSkgZXJyb3JzLnB1c2goJ0Zvcm1hdCBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghbGVuZ3RoPy50cmltKCkpIGVycm9ycy5wdXNoKCdMZW5ndGggaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIC8vIFN0YXR1cyB2YWxpZGF0aW9uXG4gIGlmICghc3Rvcnkuc3RhdHVzIHx8ICFbJ2NvbXBsZXRlZCcsICdpbl9wcm9ncmVzcycsICdmYWlsZWQnXS5pbmNsdWRlcyhzdG9yeS5zdGF0dXMpKSB7XG4gICAgZXJyb3JzLnB1c2goJ0ludmFsaWQgc3RhdHVzJyk7XG4gIH1cblxuICAvLyBDb250ZW50IGxlbmd0aCB2YWxpZGF0aW9uXG4gIGlmIChzdG9yeS5jb250ZW50Lmxlbmd0aCA8IDUwKSB7XG4gICAgZXJyb3JzLnB1c2goJ0NvbnRlbnQgbXVzdCBiZSBhdCBsZWFzdCA1MCBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgfVxuXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKGVycm9ycy5qb2luKCcsICcpLCAnSU5WQUxJRF9EQVRBJywgNDAwKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gZ2V0IHN0b3JpZXMgZm9yIHRoZSBjdXJyZW50IHVzZXJcbmV4cG9ydCBjb25zdCBnZXRTdG9yaWVzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGZldGNoIHN0b3JpZXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBxID0gcXVlcnkoXG4gICAgICBzdG9yaWVzQ29sbGVjdGlvbixcbiAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VyLnVpZCksXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgKTtcblxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIHJldHVybiBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmRvYy5kYXRhKClcbiAgICB9KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHN0b3JpZXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byBmZXRjaCBzdG9yaWVzJyxcbiAgICAgICdGRVRDSF9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIHNhdmUgYSBzdG9yeSB0byBGaXJlc3RvcmVcbmV4cG9ydCBjb25zdCBzYXZlU3RvcnkgPSBhc3luYyAoc3Rvcnk6IE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0Jz4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICB0cnkge1xuICAgIC8vIEVuc3VyZSB1c2VyIGlzIGF1dGhlbnRpY2F0ZWRcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byBzYXZlIHN0b3JpZXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBzdG9yeSBkYXRhXG4gICAgdmFsaWRhdGVTdG9yeShzdG9yeSk7XG5cbiAgICAvLyBDcmVhdGUgc3RvcnkgZGF0YSB3aXRoIHJlcXVpcmVkIGZpZWxkc1xuICAgIGNvbnN0IHN0b3J5RGF0YSA9IHtcbiAgICAgIC4uLnN0b3J5LFxuICAgICAgdXNlcklkOiB1c2VyLnVpZCwgLy8gQWx3YXlzIHVzZSB0aGUgY3VycmVudCB1c2VyJ3MgSURcbiAgICAgIGNyZWF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyBhcyBjb25zdCxcbiAgICAgIGdlbmVyYXRpb25BdHRlbXB0czogMCxcbiAgICAgIGxhc3RBdHRlbXB0QXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgdG8gc3RvcmllcyBjb2xsZWN0aW9uXG4gICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdzdG9yaWVzJyksIHN0b3J5RGF0YSk7XG4gICAgcmV0dXJuIGRvY1JlZi5pZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIEZpcmViYXNlIHNwZWNpZmljIGVycm9yc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvcikge1xuICAgICAgY29uc3QgZmlyZWJhc2VFcnJvciA9IGVycm9yIGFzIHsgY29kZTogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmcgfTtcbiAgICAgIGlmIChmaXJlYmFzZUVycm9yLmNvZGUgPT09ICdwZXJtaXNzaW9uLWRlbmllZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1Blcm1pc3Npb24gZGVuaWVkLiBQbGVhc2UgY2hlY2sgeW91ciBhdXRoZW50aWNhdGlvbiBzdGF0dXMuJywgJ1BFUk1JU1NJT05fREVOSUVEJywgNDAzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHN0b3J5OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcihcbiAgICAgICdGYWlsZWQgdG8gc2F2ZSBzdG9yeScsXG4gICAgICAnU0FWRV9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBhIHN0b3J5XG5leHBvcnQgY29uc3QgdXBkYXRlU3RvcnkgPSBhc3luYyAoc3RvcnlJZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPE9taXQ8U3RvcnksICdpZCcgfCAnY3JlYXRlZEF0JyB8ICd1c2VySWQnPj4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byB1cGRhdGUgc3RvcmllcycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgZXhpc3Rpbmcgc3RvcnkgdG8gdmVyaWZ5IG93bmVyc2hpcFxuICAgIGNvbnN0IHN0b3J5UmVmID0gZG9jKGRiLCAnc3RvcmllcycsIHN0b3J5SWQpO1xuICAgIGNvbnN0IHN0b3J5U25hcCA9IGF3YWl0IGdldERvYyhzdG9yeVJlZik7XG5cbiAgICBpZiAoIXN0b3J5U25hcC5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1N0b3J5IG5vdCBmb3VuZCcsICdOT1RfRk9VTkQnLCA0MDQpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3J5RGF0YSA9IHN0b3J5U25hcC5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIHVwZGF0ZSB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHVwZGF0ZWQgZGF0YVxuICAgIGNvbnN0IHVwZGF0ZWRTdG9yeSA9IHsgLi4uc3RvcnlEYXRhLCAuLi51cGRhdGVzIH07XG4gICAgdmFsaWRhdGVTdG9yeSh1cGRhdGVkU3RvcnkpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBzdG9yeVxuICAgIGF3YWl0IHVwZGF0ZURvYyhzdG9yeVJlZiwge1xuICAgICAgLi4udXBkYXRlcyxcbiAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gc3RvcnlJZDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgc3Rvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byB1cGRhdGUgc3RvcnknLFxuICAgICAgJ1VQREFURV9FUlJPUicsXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICdjb2RlJyBpbiBlcnJvciA/IDUwMCA6IDUwMFxuICAgICk7XG4gIH1cbn07XG5cbi8vIEZ1bmN0aW9uIHRvIGdldCBhIHNpbmdsZSBzdG9yeVxuZXhwb3J0IGNvbnN0IGdldFN0b3J5ID0gYXN5bmMgKHN0b3J5SWQ6IHN0cmluZyk6IFByb21pc2U8U3RvcnkgfCBudWxsPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gZ2V0IHN0b3JpZXMnLCAnVU5BVVRIRU5USUNBVEVEJywgNDAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yeURvYyA9IGF3YWl0IGdldERvYyhkb2MoZGIsICdzdG9yaWVzJywgc3RvcnlJZCkpO1xuICAgIGlmICghc3RvcnlEb2MuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdTdG9yeSBub3QgZm91bmQnLCAnTk9UX0ZPVU5EJywgNDA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yeURhdGEgPSBzdG9yeURvYy5kYXRhKCkgYXMgU3Rvcnk7XG4gICAgaWYgKHN0b3J5RGF0YS51c2VySWQgIT09IHVzZXIudWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVW5hdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIHN0b3J5JywgJ1VOQVVUSE9SSVpFRCcsIDQwMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBzdG9yeURvYy5pZCxcbiAgICAgIC4uLnN0b3J5RGF0YVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRmlyZWJhc2VFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc3Rvcnk6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byBnZXQgc3RvcnknLFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gQWRkIG5ldyBlcnJvciB0eXBlcyBmb3Igc3RvcnkgZ2VuZXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBTdG9yeUdlbmVyYXRpb25FcnJvciB7XG4gIGNvZGU6IHN0cmluZztcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBkZXRhaWxzPzogYW55O1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIHJldHJ5Q291bnQ/OiBudW1iZXI7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0b3J5IHdpdGggaW5pdGlhbCBzdGF0dXMgYW5kIGVycm9yIHRyYWNraW5nXG5leHBvcnQgY29uc3QgY3JlYXRlU3RvcnlXaXRoU3RhdHVzID0gYXN5bmMgKFxuICBzdG9yeTogT21pdDxTdG9yeSwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3N0YXR1cyc+LFxuICBzdGF0dXM6ICdpbl9wcm9ncmVzcycgfCAnZmFpbGVkJyA9ICdpbl9wcm9ncmVzcycsXG4gIGVycm9yPzogU3RvcnlHZW5lcmF0aW9uRXJyb3JcbikgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHVzZXIgPSBhdXRoLmN1cnJlbnRVc2VyO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoJ1VzZXIgbXVzdCBiZSBhdXRoZW50aWNhdGVkIHRvIGNyZWF0ZSBzdG9yaWVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGluaXRpYWwgc3RvcnkgZG9jdW1lbnQgd2l0aCBlcnJvciB0cmFja2luZ1xuICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhzdG9yaWVzQ29sbGVjdGlvbiwge1xuICAgICAgLi4uc3RvcnksXG4gICAgICB1c2VySWQ6IHVzZXIudWlkLFxuICAgICAgc3RhdHVzLFxuICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgIGVycm9yOiBlcnJvciA/IHtcbiAgICAgICAgLi4uZXJyb3IsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9IDogbnVsbCxcbiAgICAgIGdlbmVyYXRpb25BdHRlbXB0czogMCxcbiAgICAgIGxhc3RBdHRlbXB0QXQ6IHNlcnZlclRpbWVzdGFtcCgpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gZG9jUmVmLmlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBzdG9yeTonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoXG4gICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBzdG9yeScsXG4gICAgICAnQ1JFQVRFX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb24gdG8gdXBkYXRlIHN0b3J5IGdlbmVyYXRpb24gc3RhdHVzIHdpdGggZGV0YWlsZWQgZXJyb3IgdHJhY2tpbmdcbmV4cG9ydCBjb25zdCB1cGRhdGVTdG9yeVN0YXR1cyA9IGFzeW5jIChcbiAgc3RvcnlJZDogc3RyaW5nLFxuICBzdGF0dXM6ICdjb21wbGV0ZWQnIHwgJ2luX3Byb2dyZXNzJyB8ICdmYWlsZWQnLFxuICBlcnJvcj86IFN0b3J5R2VuZXJhdGlvbkVycm9yXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1c2VyID0gYXV0aC5jdXJyZW50VXNlcjtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVc2VyIG11c3QgYmUgYXV0aGVudGljYXRlZCB0byB1cGRhdGUgc3Rvcnkgc3RhdHVzJywgJ1VOQVVUSEVOVElDQVRFRCcsIDQwMSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlSZWYgPSBkb2MoZGIsICdzdG9yaWVzJywgc3RvcnlJZCk7XG4gICAgY29uc3Qgc3RvcnlTbmFwID0gYXdhaXQgZ2V0RG9jKHN0b3J5UmVmKTtcblxuICAgIGlmICghc3RvcnlTbmFwLmV4aXN0cygpKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignU3Rvcnkgbm90IGZvdW5kJywgJ05PVF9GT1VORCcsIDQwNCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcnlEYXRhID0gc3RvcnlTbmFwLmRhdGEoKSBhcyBTdG9yeTtcbiAgICBpZiAoc3RvcnlEYXRhLnVzZXJJZCAhPT0gdXNlci51aWQpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVbmF1dGhvcml6ZWQgdG8gdXBkYXRlIHRoaXMgc3RvcnknLCAnVU5BVVRIT1JJWkVEJywgNDAzKTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVzOiBhbnkgPSB7XG4gICAgICBzdGF0dXMsXG4gICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxuICAgICAgbGFzdEF0dGVtcHRBdDogc2VydmVyVGltZXN0YW1wKClcbiAgICB9O1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB1cGRhdGVzLmVycm9yID0ge1xuICAgICAgICAuLi5lcnJvcixcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICB1cGRhdGVzLmdlbmVyYXRpb25BdHRlbXB0cyA9IChzdG9yeURhdGEuZ2VuZXJhdGlvbkF0dGVtcHRzIHx8IDApICsgMTtcbiAgICB9XG5cbiAgICBhd2FpdCB1cGRhdGVEb2Moc3RvcnlSZWYsIHVwZGF0ZXMpO1xuICAgIHJldHVybiBzdG9yeUlkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzdG9yeSBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKFxuICAgICAgJ0ZhaWxlZCB0byB1cGRhdGUgc3Rvcnkgc3RhdHVzJyxcbiAgICAgICdVUERBVEVfRVJST1InLFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAnY29kZScgaW4gZXJyb3IgPyA1MDAgOiA1MDBcbiAgICApO1xuICB9XG59O1xuXG4vLyBGdW5jdGlvbiB0byBnZXQgc3RvcnkgZ2VuZXJhdGlvbiBzdGF0dXNcbmV4cG9ydCBjb25zdCBnZXRTdG9yeUdlbmVyYXRpb25TdGF0dXMgPSBhc3luYyAoc3RvcnlJZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXNlciA9IGF1dGguY3VycmVudFVzZXI7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWJhc2VFcnJvcignVXNlciBtdXN0IGJlIGF1dGhlbnRpY2F0ZWQgdG8gZ2V0IHN0b3J5IHN0YXR1cycsICdVTkFVVEhFTlRJQ0FURUQnLCA0MDEpO1xuICAgIH1cblxuICAgIGNvbnN0IGRvY1JlZiA9IGRvYyhkYiwgJ3N0b3JpZXMnLCBzdG9yeUlkKTtcbiAgICBjb25zdCBkb2NTbmFwID0gYXdhaXQgZ2V0RG9jKGRvY1JlZik7XG5cbiAgICBpZiAoIWRvY1NuYXAuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdTdG9yeSBub3QgZm91bmQnLCAnTk9UX0ZPVU5EJywgNDA0KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yeURhdGEgPSBkb2NTbmFwLmRhdGEoKSBhcyBTdG9yeTtcbiAgICBpZiAoc3RvcnlEYXRhLnVzZXJJZCAhPT0gdXNlci51aWQpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlYmFzZUVycm9yKCdVbmF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgc3RvcnknLCAnVU5BVVRIT1JJWkVEJywgNDAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBzdG9yeURhdGEuc3RhdHVzLFxuICAgICAgZXJyb3I6IHN0b3J5RGF0YS5lcnJvcixcbiAgICAgIGdlbmVyYXRpb25BdHRlbXB0czogc3RvcnlEYXRhLmdlbmVyYXRpb25BdHRlbXB0cyB8fCAwLFxuICAgICAgbGFzdEF0dGVtcHRBdDogc3RvcnlEYXRhLmxhc3RBdHRlbXB0QXRcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0b3J5IHN0YXR1czonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEZpcmViYXNlRXJyb3IoXG4gICAgICAnRmFpbGVkIHRvIGdldCBzdG9yeSBzdGF0dXMnLFxuICAgICAgJ0ZFVENIX0VSUk9SJyxcbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ2NvZGUnIGluIGVycm9yID8gNTAwIDogNTAwXG4gICAgKTtcbiAgfVxufTtcblxuLy8gQmF0Y2ggb3BlcmF0aW9uc1xuZXhwb3J0IGNvbnN0IGJhdGNoU2F2ZVN0b3JpZXMgPSBhc3luYyAoc3RvcmllczogT21pdDxTdG9yeSwgJ2lkJyB8ICdjcmVhdGVkQXQnPltdKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGJhdGNoID0gd3JpdGVCYXRjaChkYik7XG4gICAgY29uc3Qgc3RvcnlJZHM6IHN0cmluZ1tdID0gW107XG5cbiAgICBzdG9yaWVzLmZvckVhY2goc3RvcnkgPT4ge1xuICAgICAgdmFsaWRhdGVTdG9yeShzdG9yeSk7XG4gICAgICBjb25zdCBzdG9yeVJlZiA9IGRvYyhjb2xsZWN0aW9uKGRiLCAnc3RvcmllcycpKTtcbiAgICAgIGJhdGNoLnNldChzdG9yeVJlZiwge1xuICAgICAgICAuLi5zdG9yeSxcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcbiAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyBhcyBjb25zdFxuICAgICAgfSk7XG4gICAgICBzdG9yeUlkcy5wdXNoKHN0b3J5UmVmLmlkKTtcbiAgICB9KTtcblxuICAgIGF3YWl0IGJhdGNoLmNvbW1pdCgpO1xuICAgIHJldHVybiBzdG9yeUlkcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBiYXRjaCBzYXZpbmcgc3RvcmllczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYmF0Y2ggc2F2ZSBzdG9yaWVzJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBiYXRjaERlbGV0ZVN0b3JpZXMgPSBhc3luYyAoc3RvcnlJZHM6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgYmF0Y2ggPSB3cml0ZUJhdGNoKGRiKTtcbiAgICBcbiAgICBzdG9yeUlkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGNvbnN0IHN0b3J5UmVmID0gZG9jKGRiLCAnc3RvcmllcycsIGlkKTtcbiAgICAgIGJhdGNoLmRlbGV0ZShzdG9yeVJlZik7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBiYXRjaC5jb21taXQoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBiYXRjaCBkZWxldGluZyBzdG9yaWVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBiYXRjaCBkZWxldGUgc3RvcmllcycpO1xuICB9XG59O1xuXG4vLyBQYWdpbmF0aW9uIHN1cHBvcnRcbmV4cG9ydCBjb25zdCBnZXRTdG9yaWVzUGFnaW5hdGVkID0gYXN5bmMgKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgcGFnZVNpemU6IG51bWJlciA9IDEwLFxuICBsYXN0RG9jPzogRG9jdW1lbnRTbmFwc2hvdFxuKTogUHJvbWlzZTx7IHN0b3JpZXM6IFN0b3J5W107IGxhc3REb2M6IERvY3VtZW50U25hcHNob3QgfCBudWxsIH0+ID0+IHtcbiAgdHJ5IHtcbiAgICBsZXQgcSA9IHF1ZXJ5KFxuICAgICAgY29sbGVjdGlvbihkYiwgJ3N0b3JpZXMnKSxcbiAgICAgIHdoZXJlKCd1c2VySWQnLCAnPT0nLCB1c2VySWQpLFxuICAgICAgb3JkZXJCeSgnY3JlYXRlZEF0JywgJ2Rlc2MnKSxcbiAgICAgIGxpbWl0KHBhZ2VTaXplKVxuICAgICk7XG5cbiAgICBpZiAobGFzdERvYykge1xuICAgICAgcSA9IHF1ZXJ5KHEsIHN0YXJ0QWZ0ZXIobGFzdERvYykpO1xuICAgIH1cblxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHEpO1xuICAgIGNvbnN0IHN0b3JpZXMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmRvYy5kYXRhKClcbiAgICB9IGFzIFN0b3J5KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmllcyxcbiAgICAgIGxhc3REb2M6IHF1ZXJ5U25hcHNob3QuZG9jc1txdWVyeVNuYXBzaG90LmRvY3MubGVuZ3RoIC0gMV0gfHwgbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBwYWdpbmF0ZWQgc3RvcmllczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHBhZ2luYXRlZCBzdG9yaWVzJyk7XG4gIH1cbn07XG5cbi8vIFNlYXJjaCBzdG9yaWVzXG5leHBvcnQgY29uc3Qgc2VhcmNoU3RvcmllcyA9IGFzeW5jIChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHNlYXJjaFRlcm06IHN0cmluZ1xuKTogUHJvbWlzZTxTdG9yeVtdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3Rvcmllc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICBjb2xsZWN0aW9uKGRiLCAnc3RvcmllcycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZCksXG4gICAgICBvcmRlckJ5KCdjcmVhdGVkQXQnLCAnZGVzYycpXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBxdWVyeVNuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhzdG9yaWVzUXVlcnkpO1xuICAgIGNvbnN0IHN0b3JpZXMgPSBxdWVyeVNuYXBzaG90LmRvY3MubWFwKGRvYyA9PiAoe1xuICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgIC4uLmRvYy5kYXRhKClcbiAgICB9IGFzIFN0b3J5KSk7XG5cbiAgICAvLyBDbGllbnQtc2lkZSBzZWFyY2ggZm9yIGJldHRlciBmbGV4aWJpbGl0eVxuICAgIHJldHVybiBzdG9yaWVzLmZpbHRlcihzdG9yeSA9PiBcbiAgICAgIHN0b3J5LnRpdGxlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgc3RvcnkuY29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgIHN0b3J5LmNvbmZpZy5mb2N1cy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0udG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgIHN0b3J5LmNvbmZpZy50b25lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc2VhcmNoVGVybS50b0xvd2VyQ2FzZSgpKVxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIHN0b3JpZXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNlYXJjaCBzdG9yaWVzJyk7XG4gIH1cbn07XG5cbi8vIFN0b3J5IHN0YXRpc3RpY3NcbmV4cG9ydCBjb25zdCBnZXRTdG9yeVN0YXRzID0gYXN5bmMgKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx7XG4gIHRvdGFsOiBudW1iZXI7XG4gIGNvbXBsZXRlZDogbnVtYmVyO1xuICBpblByb2dyZXNzOiBudW1iZXI7XG4gIGZhaWxlZDogbnVtYmVyO1xuICBieUZvY3VzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICBieVRvbmU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG59PiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3Rvcmllc1F1ZXJ5ID0gcXVlcnkoXG4gICAgICBjb2xsZWN0aW9uKGRiLCAnc3RvcmllcycpLFxuICAgICAgd2hlcmUoJ3VzZXJJZCcsICc9PScsIHVzZXJJZClcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5U25hcHNob3QgPSBhd2FpdCBnZXREb2NzKHN0b3JpZXNRdWVyeSk7XG4gICAgY29uc3Qgc3RvcmllcyA9IHF1ZXJ5U25hcHNob3QuZG9jcy5tYXAoZG9jID0+IGRvYy5kYXRhKCkgYXMgU3RvcnkpO1xuXG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICB0b3RhbDogc3Rvcmllcy5sZW5ndGgsXG4gICAgICBjb21wbGV0ZWQ6IDAsXG4gICAgICBpblByb2dyZXNzOiAwLFxuICAgICAgZmFpbGVkOiAwLFxuICAgICAgYnlGb2N1czoge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICAgIGJ5VG9uZToge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPlxuICAgIH07XG5cbiAgICBzdG9yaWVzLmZvckVhY2goc3RvcnkgPT4ge1xuICAgICAgLy8gQ291bnQgYnkgc3RhdHVzXG4gICAgICBzdGF0c1tzdG9yeS5zdGF0dXNdKys7XG4gICAgICBcbiAgICAgIC8vIENvdW50IGJ5IGZvY3VzXG4gICAgICBzdGF0cy5ieUZvY3VzW3N0b3J5LmNvbmZpZy5mb2N1c10gPSAoc3RhdHMuYnlGb2N1c1tzdG9yeS5jb25maWcuZm9jdXNdIHx8IDApICsgMTtcbiAgICAgIFxuICAgICAgLy8gQ291bnQgYnkgdG9uZVxuICAgICAgc3RhdHMuYnlUb25lW3N0b3J5LmNvbmZpZy50b25lXSA9IChzdGF0cy5ieVRvbmVbc3RvcnkuY29uZmlnLnRvbmVdIHx8IDApICsgMTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdGF0cztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0b3J5IHN0YXRzOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgc3Rvcnkgc3RhdGlzdGljcycpO1xuICB9XG59O1xuXG5leHBvcnQgeyBhcHAsIGF1dGgsIGRiLCBhbmFseXRpY3MgfTsgIl0sIm5hbWVzIjpbImluaXRpYWxpemVBcHAiLCJnZXRBcHBzIiwiZ2V0QXBwIiwiZ2V0QXV0aCIsImdldEZpcmVzdG9yZSIsImNvbGxlY3Rpb24iLCJhZGREb2MiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJxdWVyeSIsIndoZXJlIiwib3JkZXJCeSIsImdldERvY3MiLCJkb2MiLCJnZXREb2MiLCJ1cGRhdGVEb2MiLCJ3cml0ZUJhdGNoIiwibGltaXQiLCJzdGFydEFmdGVyIiwiZ2V0QW5hbHl0aWNzIiwiY29uc29sZSIsImxvZyIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZIiwiYXV0aERvbWFpbiIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOIiwicHJvamVjdElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCIsInN0b3JhZ2VCdWNrZXQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9TVE9SQUdFX0JVQ0tFVCIsIm1lc3NhZ2luZ1NlbmRlcklkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVTU0FHSU5HX1NFTkRFUl9JRCIsImFwcElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lEIiwibWVhc3VyZW1lbnRJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FQVNVUkVNRU5UX0lEIiwiZmlyZWJhc2VDb25maWciLCJhcHAiLCJsZW5ndGgiLCJhdXRoIiwiZGIiLCJhbmFseXRpY3MiLCJlcnJvciIsInN0b3JpZXNDb2xsZWN0aW9uIiwiRmlyZWJhc2VFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiY29kZSIsInN0YXR1cyIsIm5hbWUiLCJ2YWxpZGF0ZVN0b3J5Iiwic3RvcnkiLCJlcnJvcnMiLCJ0aXRsZSIsInRyaW0iLCJwdXNoIiwiY29udGVudCIsInVzZXJJZCIsImNvbmZpZyIsImZvY3VzIiwidG9uZSIsImZvcm1hdCIsImluY2x1ZGVzIiwiam9pbiIsImdldFN0b3JpZXMiLCJ1c2VyIiwiY3VycmVudFVzZXIiLCJxIiwidWlkIiwicXVlcnlTbmFwc2hvdCIsImRvY3MiLCJtYXAiLCJpZCIsImRhdGEiLCJzYXZlU3RvcnkiLCJzdG9yeURhdGEiLCJjcmVhdGVkQXQiLCJ1cGRhdGVkQXQiLCJnZW5lcmF0aW9uQXR0ZW1wdHMiLCJsYXN0QXR0ZW1wdEF0IiwiZG9jUmVmIiwiZmlyZWJhc2VFcnJvciIsInVwZGF0ZVN0b3J5Iiwic3RvcnlJZCIsInVwZGF0ZXMiLCJzdG9yeVJlZiIsInN0b3J5U25hcCIsImV4aXN0cyIsInVwZGF0ZWRTdG9yeSIsImdldFN0b3J5Iiwic3RvcnlEb2MiLCJjcmVhdGVTdG9yeVdpdGhTdGF0dXMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVTdG9yeVN0YXR1cyIsImdldFN0b3J5R2VuZXJhdGlvblN0YXR1cyIsImRvY1NuYXAiLCJiYXRjaFNhdmVTdG9yaWVzIiwic3RvcmllcyIsImJhdGNoIiwic3RvcnlJZHMiLCJmb3JFYWNoIiwic2V0IiwiY29tbWl0IiwiYmF0Y2hEZWxldGVTdG9yaWVzIiwiZGVsZXRlIiwiZ2V0U3Rvcmllc1BhZ2luYXRlZCIsInBhZ2VTaXplIiwibGFzdERvYyIsInNlYXJjaFN0b3JpZXMiLCJzZWFyY2hUZXJtIiwic3Rvcmllc1F1ZXJ5IiwiZmlsdGVyIiwidG9Mb3dlckNhc2UiLCJnZXRTdG9yeVN0YXRzIiwic3RhdHMiLCJ0b3RhbCIsImNvbXBsZXRlZCIsImluUHJvZ3Jlc3MiLCJmYWlsZWQiLCJieUZvY3VzIiwiYnlUb25lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firebase.ts\n"));

/***/ })

});